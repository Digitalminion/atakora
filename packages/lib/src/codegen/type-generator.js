"use strict";
/**
 * TypeScript Type Generator - Generates TypeScript interfaces from ARM schema IR.
 *
 * @packageDocumentation
 */
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeGenerator = void 0;
var path = require("path");
/**
 * Generates TypeScript interface code from schema IR.
 *
 * @remarks
 * Produces clean, well-documented TypeScript interfaces matching
 * the existing hand-written type patterns in the codebase.
 *
 * @example
 * ```typescript
 * const parser = new SchemaParser();
 * const ir = parser.parse('path/to/schema.json');
 *
 * const generator = new TypeGenerator();
 * const code = generator.generate(ir);
 *
 * fs.writeFileSync('generated-types.ts', code);
 * ```
 */
var TypeGenerator = /** @class */ (function () {
    function TypeGenerator() {
    }
    /**
     * Generate TypeScript types file from schema IR.
     *
     * @param ir - Schema intermediate representation
     * @returns Generated TypeScript code
     * @throws {Error} If referenced types are not defined
     */
    TypeGenerator.prototype.generate = function (ir) {
        var lines = [];
        // File header
        lines.push(this.generateFileHeader(ir.metadata));
        lines.push('');
        // Generate shared type definitions first
        var generatedTypes = new Set();
        var referencedTypes = new Set();
        for (var _i = 0, _a = ir.definitions; _i < _a.length; _i++) {
            var _b = _a[_i], name_1 = _b[0], typeDef = _b[1];
            var typeName = this.toTypeName(name_1);
            // Track this type as "generated" (available for reference)
            // even if we don't emit an interface for it
            generatedTypes.add(typeName);
            // Generate type definitions based on kind
            if (typeDef.kind === 'object' && typeDef.properties) {
                // Object type with properties - generate interface
                if (!lines.includes("export interface ".concat(typeName))) {
                    lines.push(this.generateInterface(name_1, typeDef));
                    lines.push('');
                }
            }
            else if (typeDef.kind === 'union') {
                // Union type - generate type alias
                if (!lines.includes("export type ".concat(typeName))) {
                    lines.push(this.generateTypeAlias(name_1, typeDef));
                    lines.push('');
                }
            }
            // Track any type references in this definition
            this.collectTypeReferences(typeDef, referencedTypes);
        }
        // Generate resource prop interfaces
        for (var _c = 0, _d = ir.resources; _c < _d.length; _c++) {
            var resource = _d[_c];
            lines.push(this.generateResourcePropsInterface(resource, ir));
            lines.push('');
            // Track references in resource properties
            for (var _e = 0, _f = resource.properties; _e < _f.length; _e++) {
                var prop = _f[_e];
                this.collectTypeReferences(prop.type, referencedTypes);
            }
        }
        // Validate all referenced types are defined
        this.validateTypeReferences(generatedTypes, referencedTypes, ir.metadata);
        return lines.join('\n');
    };
    /**
     * Generate file header with metadata and documentation.
     *
     * @param metadata - Schema metadata
     * @returns Header comment block
     */
    TypeGenerator.prototype.generateFileHeader = function (metadata) {
        return "/**\n * Type definitions for ".concat(metadata.provider, " resources.\n *\n * **API Version**: ").concat(metadata.apiVersion, "\n * **Generated**: ").concat(metadata.generatedAt, "\n * **Source**: ").concat(path.basename(metadata.schemaPath), "\n *\n * @remarks\n * This file is auto-generated. Do not edit manually.\n * Generated by Felix (Schema & Validation Engineer)\n *\n * @packageDocumentation\n */");
    };
    /**
     * Generate TypeScript type alias for union types.
     *
     * @param name - Type definition name
     * @param typeDef - Type definition
     * @returns Generated type alias code
     */
    TypeGenerator.prototype.generateTypeAlias = function (name, typeDef) {
        var lines = [];
        var typeName = this.toTypeName(name);
        // Type alias JSDoc
        lines.push("/**");
        lines.push(" * ".concat(typeName, " type."));
        lines.push(" */");
        // Type alias declaration
        lines.push("export type ".concat(typeName, " = ").concat(typeDef.tsType, ";"));
        return lines.join('\n');
    };
    /**
     * Generate TypeScript interface for shared type definition.
     *
     * @param name - Type definition name
     * @param typeDef - Type definition
     * @returns Generated interface code
     */
    TypeGenerator.prototype.generateInterface = function (name, typeDef) {
        var lines = [];
        var typeName = this.toTypeName(name);
        // Interface JSDoc
        lines.push("/**");
        lines.push(" * ".concat(typeName, " definition."));
        lines.push(" */");
        // Interface declaration
        lines.push("export interface ".concat(typeName, " {"));
        // Properties
        if (typeDef.properties) {
            for (var _i = 0, _a = typeDef.properties; _i < _a.length; _i++) {
                var prop = _a[_i];
                lines.push(this.generatePropertyDoc(prop, '  '));
                lines.push(this.generatePropertyDeclaration(prop, '  '));
            }
        }
        lines.push("}");
        return lines.join('\n');
    };
    /**
     * Generate resource props interface for L1 construct.
     *
     * @param resource - Resource definition
     * @param ir - Schema IR (for metadata)
     * @returns Generated interface code
     */
    TypeGenerator.prototype.generateResourcePropsInterface = function (resource, ir) {
        var lines = [];
        var propsName = "Arm".concat(this.toPascalCase(resource.name), "Props");
        // Interface JSDoc with full documentation
        lines.push("/**");
        lines.push(" * Properties for ".concat(resource.armType, " (L1 construct)."));
        lines.push(" *");
        if (resource.description) {
            lines.push(" * @remarks");
            lines.push(" * ".concat(resource.description));
            lines.push(" *");
        }
        lines.push(" * **ARM Resource Type**: `".concat(resource.armType, "`"));
        lines.push(" * **API Version**: `".concat(ir.apiVersion, "`"));
        lines.push(" *");
        lines.push(" * Direct mapping to ARM resource properties with no defaults or transformations.");
        lines.push(" */");
        // Interface declaration
        lines.push("export interface ".concat(propsName, " {"));
        // Properties
        for (var _i = 0, _a = resource.properties; _i < _a.length; _i++) {
            var prop = _a[_i];
            // Skip ARM metadata properties (type, apiVersion handled automatically)
            if (['type', 'apiVersion', 'resources'].includes(prop.name)) {
                continue;
            }
            lines.push(this.generatePropertyDoc(prop, '  '));
            lines.push(this.generatePropertyDeclaration(prop, '  '));
        }
        lines.push("}");
        return lines.join('\n');
    };
    /**
     * Generate JSDoc comment for a property.
     *
     * @param prop - Property definition
     * @param indent - Indentation string
     * @returns JSDoc comment block
     */
    TypeGenerator.prototype.generatePropertyDoc = function (prop, indent) {
        var _a, _b, _c, _d;
        var lines = [];
        lines.push("".concat(indent, "/**"));
        if (prop.description) {
            // Split description into lines if needed
            var descLines = prop.description.split('\n');
            for (var _i = 0, descLines_1 = descLines; _i < descLines_1.length; _i++) {
                var line = descLines_1[_i];
                lines.push("".concat(indent, " * ").concat(line));
            }
        }
        else {
            lines.push("".concat(indent, " * ").concat(prop.name));
        }
        // Add constraints to documentation
        if (prop.constraints) {
            lines.push("".concat(indent, " *"));
            lines.push("".concat(indent, " * @remarks"));
            if (prop.constraints.minLength !== undefined || prop.constraints.maxLength !== undefined) {
                var min = (_a = prop.constraints.minLength) !== null && _a !== void 0 ? _a : 0;
                var max = (_b = prop.constraints.maxLength) !== null && _b !== void 0 ? _b : 'unlimited';
                lines.push("".concat(indent, " * Length: ").concat(min, "-").concat(max, " characters"));
            }
            if (prop.constraints.pattern) {
                lines.push("".concat(indent, " * Pattern: `").concat(prop.constraints.pattern, "`"));
            }
            if (prop.constraints.minimum !== undefined || prop.constraints.maximum !== undefined) {
                var min = (_c = prop.constraints.minimum) !== null && _c !== void 0 ? _c : '-∞';
                var max = (_d = prop.constraints.maximum) !== null && _d !== void 0 ? _d : '∞';
                lines.push("".concat(indent, " * Range: ").concat(min, " to ").concat(max));
            }
        }
        lines.push("".concat(indent, " */"));
        return lines.join('\n');
    };
    /**
     * Generate TypeScript property declaration.
     *
     * @param prop - Property definition
     * @param indent - Indentation string
     * @returns Property declaration line
     */
    TypeGenerator.prototype.generatePropertyDeclaration = function (prop, indent) {
        var optional = prop.required ? '' : '?';
        return "".concat(indent, "readonly ").concat(prop.name).concat(optional, ": ").concat(prop.type.tsType, ";");
    };
    /**
     * Convert name to PascalCase for type names.
     *
     * @param name - Original name
     * @returns PascalCase name
     */
    TypeGenerator.prototype.toPascalCase = function (name) {
        // Handle already PascalCase names
        if (/^[A-Z]/.test(name)) {
            return name;
        }
        // Split on various separators and capitalize
        return name
            .split(/[_\-\/]/)
            .map(function (part) { return part.charAt(0).toUpperCase() + part.slice(1); })
            .join('');
    };
    /**
     * Convert definition name to TypeScript type name.
     *
     * @param name - Definition name from schema
     * @returns Clean TypeScript type name
     */
    TypeGenerator.prototype.toTypeName = function (name) {
        // Remove common ARM suffixes
        return name
            .replace(/PropertiesFormat$/, '')
            .replace(/Format$/, '')
            .replace(/Properties$/, 'Props');
    };
    /**
     * Collect all type references from a type definition.
     *
     * @param typeDef - Type definition to scan
     * @param referencedTypes - Set to collect references into
     */
    TypeGenerator.prototype.collectTypeReferences = function (typeDef, referencedTypes) {
        if (typeDef.kind === 'reference') {
            // Add the actual tsType which has been transformed
            referencedTypes.add(typeDef.tsType);
        }
        else if (typeDef.kind === 'array' && typeDef.elementType) {
            this.collectTypeReferences(typeDef.elementType, referencedTypes);
        }
        else if (typeDef.kind === 'union' && typeDef.unionTypes) {
            for (var _i = 0, _a = typeDef.unionTypes; _i < _a.length; _i++) {
                var unionType = _a[_i];
                this.collectTypeReferences(unionType, referencedTypes);
            }
        }
        else if (typeDef.kind === 'object' && typeDef.properties) {
            for (var _b = 0, _c = typeDef.properties; _b < _c.length; _b++) {
                var prop = _c[_b];
                this.collectTypeReferences(prop.type, referencedTypes);
            }
        }
    };
    /**
     * Validate that all referenced types are actually defined.
     *
     * @param generatedTypes - Set of types that were generated
     * @param referencedTypes - Set of types that were referenced
     * @param metadata - Schema metadata for error messages
     * @throws {Error} If any referenced type is not defined
     */
    TypeGenerator.prototype.validateTypeReferences = function (generatedTypes, referencedTypes, metadata) {
        var missingTypes = [];
        var _loop_1 = function (refType) {
            // Skip primitive types and common TypeScript types
            var primitives = ['string', 'number', 'boolean', 'any', 'object'];
            var isPrimitive = primitives.some(function (p) { return refType.includes(p); });
            var isRecord = refType.startsWith('Record<');
            var isArray = refType.endsWith('[]');
            if (isPrimitive || isRecord || isArray) {
                return "continue";
            }
            // Check if the referenced type was generated
            if (!generatedTypes.has(refType)) {
                missingTypes.push(refType);
            }
        };
        for (var _i = 0, referencedTypes_1 = referencedTypes; _i < referencedTypes_1.length; _i++) {
            var refType = referencedTypes_1[_i];
            _loop_1(refType);
        }
        if (missingTypes.length > 0) {
            var errorMsg = __spreadArray(__spreadArray([
                "Type generation validation failed for ".concat(metadata.provider, ":"),
                "",
                "The following types are referenced but not defined:"
            ], missingTypes.map(function (t) { return "  - ".concat(t); }), true), [
                "",
                "This indicates either:",
                "  1. Missing definitions in the ARM schema",
                "  2. A bug in the type name transformation logic",
                "  3. External type references that need to be imported",
                "",
                "Please review the schema and type generation logic.",
            ], false).join('\n');
            throw new Error(errorMsg);
        }
    };
    return TypeGenerator;
}());
exports.TypeGenerator = TypeGenerator;
