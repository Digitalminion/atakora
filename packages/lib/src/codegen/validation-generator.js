"use strict";
/**
 * Validation Code Generator - Generates runtime validation functions from ARM schemas.
 *
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationGenerator = void 0;
/**
 * Generates runtime validation code from ARM schema constraints.
 *
 * @remarks
 * Produces TypeScript validator functions that check:
 * - Required properties
 * - String length constraints
 * - Numeric range constraints
 * - Regex patterns
 * - Enum values
 *
 * @example
 * ```typescript
 * const parser = new SchemaParser();
 * const ir = parser.parse('path/to/schema.json');
 *
 * const generator = new ValidationGenerator();
 * const code = generator.generate(ir);
 *
 * fs.writeFileSync('validators.ts', code);
 * ```
 */
var ValidationGenerator = /** @class */ (function () {
    function ValidationGenerator() {
    }
    /**
     * Generate validation code from schema IR.
     *
     * @param ir - Schema intermediate representation
     * @returns Generated validation code
     */
    ValidationGenerator.prototype.generate = function (ir) {
        var lines = [];
        // File header
        lines.push(this.generateFileHeader(ir.metadata));
        lines.push('');
        // Import validation types
        lines.push(this.generateImports());
        lines.push('');
        // Generate validators for each resource
        for (var _i = 0, _a = ir.resources; _i < _a.length; _i++) {
            var resource = _a[_i];
            lines.push(this.generateResourceValidator(resource, ir));
            lines.push('');
        }
        return lines.join('\n');
    };
    /**
     * Generate file header.
     */
    ValidationGenerator.prototype.generateFileHeader = function (metadata) {
        return "/**\n * Runtime validators for ".concat(metadata.provider, " resources.\n *\n * **API Version**: ").concat(metadata.apiVersion, "\n * **Generated**: ").concat(metadata.generatedAt, "\n *\n * @remarks\n * This file is auto-generated. Do not edit manually.\n * Generated by Felix (Schema & Validation Engineer)\n *\n * @packageDocumentation\n */");
    };
    /**
     * Generate imports.
     */
    ValidationGenerator.prototype.generateImports = function () {
        return "/**\n * Validation error.\n */\nexport interface ValidationError {\n  readonly path: string;\n  readonly message: string;\n  readonly code: string;\n  readonly fix?: string;\n}\n\n/**\n * Validation result.\n */\nexport interface ValidationResult {\n  readonly valid: boolean;\n  readonly errors: ValidationError[];\n}";
    };
    /**
     * Generate validator function for a resource.
     */
    ValidationGenerator.prototype.generateResourceValidator = function (resource, ir) {
        var lines = [];
        var validatorName = "validate".concat(this.toPascalCase(resource.name));
        var propsTypeName = "Arm".concat(this.toPascalCase(resource.name), "Props");
        // Function JSDoc
        lines.push("/**");
        lines.push(" * Validate ".concat(resource.armType, " properties."));
        lines.push(" *");
        lines.push(" * @param props - Resource properties to validate");
        lines.push(" * @returns Validation result");
        lines.push(" */");
        // Function signature
        lines.push("export function ".concat(validatorName, "(props: any): ValidationResult {"));
        lines.push("  const errors: ValidationError[] = [];");
        lines.push('');
        // Validate required properties
        for (var _i = 0, _a = resource.properties; _i < _a.length; _i++) {
            var prop = _a[_i];
            if (prop.required && !['type', 'apiVersion', 'resources'].includes(prop.name)) {
                lines.push("  // Validate required property: ".concat(prop.name));
                lines.push("  if (props.".concat(prop.name, " === undefined || props.").concat(prop.name, " === null) {"));
                lines.push("    errors.push({");
                lines.push("      path: '".concat(prop.name, "',"));
                lines.push("      message: 'Required property \"".concat(prop.name, "\" is missing',"));
                lines.push("      code: 'REQUIRED_PROPERTY_MISSING',");
                lines.push("      fix: 'Add the \"".concat(prop.name, "\" property to your resource definition'"));
                lines.push("    });");
                lines.push("  }");
                lines.push('');
            }
        }
        // Validate constraints on properties
        for (var _b = 0, _c = resource.properties; _b < _c.length; _b++) {
            var prop = _c[_b];
            if (prop.constraints) {
                lines.push.apply(lines, this.generatePropertyValidation(prop, '  '));
            }
        }
        // Return result
        lines.push("  return {");
        lines.push("    valid: errors.length === 0,");
        lines.push("    errors");
        lines.push("  };");
        lines.push("}");
        return lines.join('\n');
    };
    /**
     * Generate validation code for a property with constraints.
     */
    ValidationGenerator.prototype.generatePropertyValidation = function (prop, indent) {
        var lines = [];
        var constraints = prop.constraints;
        lines.push("".concat(indent, "// Validate constraints on: ").concat(prop.name));
        lines.push("".concat(indent, "if (props.").concat(prop.name, " !== undefined && props.").concat(prop.name, " !== null) {"));
        // String length constraints
        if (constraints.minLength !== undefined || constraints.maxLength !== undefined) {
            lines.push("".concat(indent, "  if (typeof props.").concat(prop.name, " === 'string') {"));
            if (constraints.minLength !== undefined) {
                lines.push("".concat(indent, "    if (props.").concat(prop.name, ".length < ").concat(constraints.minLength, ") {"));
                lines.push("".concat(indent, "      errors.push({"));
                lines.push("".concat(indent, "        path: '").concat(prop.name, "',"));
                lines.push("".concat(indent, "        message: 'Property \"").concat(prop.name, "\" must be at least ").concat(constraints.minLength, " characters',"));
                lines.push("".concat(indent, "        code: 'STRING_TOO_SHORT',"));
                lines.push("".concat(indent, "        fix: 'Provide a longer value for \"").concat(prop.name, "\"'"));
                lines.push("".concat(indent, "      });"));
                lines.push("".concat(indent, "    }"));
            }
            if (constraints.maxLength !== undefined) {
                lines.push("".concat(indent, "    if (props.").concat(prop.name, ".length > ").concat(constraints.maxLength, ") {"));
                lines.push("".concat(indent, "      errors.push({"));
                lines.push("".concat(indent, "        path: '").concat(prop.name, "',"));
                lines.push("".concat(indent, "        message: 'Property \"").concat(prop.name, "\" must be at most ").concat(constraints.maxLength, " characters',"));
                lines.push("".concat(indent, "        code: 'STRING_TOO_LONG',"));
                lines.push("".concat(indent, "        fix: 'Shorten the value of \"").concat(prop.name, "\" to ").concat(constraints.maxLength, " characters or less'"));
                lines.push("".concat(indent, "      });"));
                lines.push("".concat(indent, "    }"));
            }
            lines.push("".concat(indent, "  }"));
        }
        // Numeric range constraints
        if (constraints.minimum !== undefined || constraints.maximum !== undefined) {
            lines.push("".concat(indent, "  if (typeof props.").concat(prop.name, " === 'number') {"));
            if (constraints.minimum !== undefined) {
                lines.push("".concat(indent, "    if (props.").concat(prop.name, " < ").concat(constraints.minimum, ") {"));
                lines.push("".concat(indent, "      errors.push({"));
                lines.push("".concat(indent, "        path: '").concat(prop.name, "',"));
                lines.push("".concat(indent, "        message: 'Property \"").concat(prop.name, "\" must be at least ").concat(constraints.minimum, "',"));
                lines.push("".concat(indent, "        code: 'VALUE_TOO_SMALL',"));
                lines.push("".concat(indent, "        fix: 'Increase the value of \"").concat(prop.name, "\" to ").concat(constraints.minimum, " or greater'"));
                lines.push("".concat(indent, "      });"));
                lines.push("".concat(indent, "    }"));
            }
            if (constraints.maximum !== undefined) {
                lines.push("".concat(indent, "    if (props.").concat(prop.name, " > ").concat(constraints.maximum, ") {"));
                lines.push("".concat(indent, "      errors.push({"));
                lines.push("".concat(indent, "        path: '").concat(prop.name, "',"));
                lines.push("".concat(indent, "        message: 'Property \"").concat(prop.name, "\" must be at most ").concat(constraints.maximum, "',"));
                lines.push("".concat(indent, "        code: 'VALUE_TOO_LARGE',"));
                lines.push("".concat(indent, "        fix: 'Decrease the value of \"").concat(prop.name, "\" to ").concat(constraints.maximum, " or less'"));
                lines.push("".concat(indent, "      });"));
                lines.push("".concat(indent, "    }"));
            }
            lines.push("".concat(indent, "  }"));
        }
        // Pattern constraints
        if (constraints.pattern) {
            var escapedPattern = constraints.pattern.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            lines.push("".concat(indent, "  if (typeof props.").concat(prop.name, " === 'string') {"));
            lines.push("".concat(indent, "    const pattern = new RegExp('").concat(escapedPattern, "');"));
            lines.push("".concat(indent, "    if (!pattern.test(props.").concat(prop.name, ")) {"));
            lines.push("".concat(indent, "      errors.push({"));
            lines.push("".concat(indent, "        path: '").concat(prop.name, "',"));
            lines.push("".concat(indent, "        message: 'Property \"").concat(prop.name, "\" does not match required pattern',"));
            lines.push("".concat(indent, "        code: 'PATTERN_MISMATCH',"));
            lines.push("".concat(indent, "        fix: 'Ensure \"").concat(prop.name, "\" matches the pattern: ").concat(escapedPattern, "'"));
            lines.push("".concat(indent, "      });"));
            lines.push("".concat(indent, "    }"));
            lines.push("".concat(indent, "  }"));
        }
        // Enum constraints
        if (constraints.enum && constraints.enum.length > 0) {
            var enumValues = constraints.enum.map(function (v) { return "'".concat(v, "'"); }).join(', ');
            lines.push("".concat(indent, "  const allowedValues = [").concat(enumValues, "];"));
            lines.push("".concat(indent, "  if (!allowedValues.includes(props.").concat(prop.name, ")) {"));
            lines.push("".concat(indent, "    errors.push({"));
            lines.push("".concat(indent, "      path: '").concat(prop.name, "',"));
            lines.push("".concat(indent, "      message: 'Property \"").concat(prop.name, "\" must be one of: ").concat(enumValues, "',"));
            lines.push("".concat(indent, "      code: 'INVALID_ENUM_VALUE',"));
            lines.push("".concat(indent, "      fix: 'Use one of the allowed values: ").concat(enumValues, "'"));
            lines.push("".concat(indent, "    });"));
            lines.push("".concat(indent, "  }"));
        }
        lines.push("".concat(indent, "}"));
        lines.push('');
        return lines;
    };
    /**
     * Convert name to PascalCase.
     */
    ValidationGenerator.prototype.toPascalCase = function (name) {
        if (/^[A-Z]/.test(name)) {
            return name;
        }
        return name
            .split(/[_\-\/]/)
            .map(function (part) { return part.charAt(0).toUpperCase() + part.slice(1); })
            .join('');
    };
    return ValidationGenerator;
}());
exports.ValidationGenerator = ValidationGenerator;
