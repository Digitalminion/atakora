/**
 * Validation Code Generator - Generates runtime validation functions from ARM schemas.
 *
 * @packageDocumentation
 */

import type {
  SchemaIR,
  ResourceDefinition,
  PropertyDefinition,
  PropertyConstraints,
} from './types';

/**
 * Validation error result.
 */
export interface ValidationError {
  /** Property path where error occurred */
  readonly path: string;
  /** Error message */
  readonly message: string;
  /** Error code */
  readonly code: string;
  /** Suggested fix */
  readonly fix?: string;
}

/**
 * Validation result.
 */
export interface ValidationResult {
  /** Validation passed */
  readonly valid: boolean;
  /** Validation errors */
  readonly errors: ValidationError[];
}

/**
 * Generates runtime validation code from ARM schema constraints.
 *
 * @remarks
 * Produces TypeScript validator functions that check:
 * - Required properties
 * - String length constraints
 * - Numeric range constraints
 * - Regex patterns
 * - Enum values
 *
 * @example
 * ```typescript
 * const parser = new SchemaParser();
 * const ir = parser.parse('path/to/schema.json');
 *
 * const generator = new ValidationGenerator();
 * const code = generator.generate(ir);
 *
 * fs.writeFileSync('validators.ts', code);
 * ```
 */
export class ValidationGenerator {
  /**
   * Generate validation code from schema IR.
   *
   * @param ir - Schema intermediate representation
   * @returns Generated validation code
   */
  public generate(ir: SchemaIR): string {
    const lines: string[] = [];

    // File header
    lines.push(this.generateFileHeader(ir.metadata));
    lines.push('');

    // Import validation types
    lines.push(this.generateImports());
    lines.push('');

    // Generate validators for each resource
    for (const resource of ir.resources) {
      lines.push(this.generateResourceValidator(resource, ir));
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate file header.
   */
  private generateFileHeader(metadata: any): string {
    return `/**
 * Runtime validators for ${metadata.provider} resources.
 *
 * **API Version**: ${metadata.apiVersion}
 * **Generated**: ${metadata.generatedAt}
 *
 * @remarks
 * This file is auto-generated. Do not edit manually.
 * Generated by Felix (Schema & Validation Engineer)
 *
 * @packageDocumentation
 */`;
  }

  /**
   * Generate imports.
   */
  private generateImports(): string {
    return `/**
 * Validation error.
 */
export interface ValidationError {
  readonly path: string;
  readonly message: string;
  readonly code: string;
  readonly fix?: string;
}

/**
 * Validation result.
 */
export interface ValidationResult {
  readonly valid: boolean;
  readonly errors: ValidationError[];
}`;
  }

  /**
   * Generate validator function for a resource.
   */
  private generateResourceValidator(
    resource: ResourceDefinition,
    ir: SchemaIR
  ): string {
    const lines: string[] = [];
    const validatorName = `validate${this.toPascalCase(resource.name)}`;
    const propsTypeName = `Arm${this.toPascalCase(resource.name)}Props`;

    // Function JSDoc
    lines.push(`/**`);
    lines.push(` * Validate ${resource.armType} properties.`);
    lines.push(` *`);
    lines.push(` * @param props - Resource properties to validate`);
    lines.push(` * @returns Validation result`);
    lines.push(` */`);

    // Function signature
    lines.push(`export function ${validatorName}(props: any): ValidationResult {`);
    lines.push(`  const errors: ValidationError[] = [];`);
    lines.push('');

    // Validate required properties
    for (const prop of resource.properties) {
      if (
        prop.required &&
        !['type', 'apiVersion', 'resources'].includes(prop.name)
      ) {
        lines.push(`  // Validate required property: ${prop.name}`);
        lines.push(`  if (props.${prop.name} === undefined || props.${prop.name} === null) {`);
        lines.push(`    errors.push({`);
        lines.push(`      path: '${prop.name}',`);
        lines.push(`      message: 'Required property "${prop.name}" is missing',`);
        lines.push(`      code: 'REQUIRED_PROPERTY_MISSING',`);
        lines.push(`      fix: 'Add the "${prop.name}" property to your resource definition'`);
        lines.push(`    });`);
        lines.push(`  }`);
        lines.push('');
      }
    }

    // Validate constraints on properties
    for (const prop of resource.properties) {
      if (prop.constraints) {
        lines.push(...this.generatePropertyValidation(prop, '  '));
      }
    }

    // Return result
    lines.push(`  return {`);
    lines.push(`    valid: errors.length === 0,`);
    lines.push(`    errors`);
    lines.push(`  };`);
    lines.push(`}`);

    return lines.join('\n');
  }

  /**
   * Generate validation code for a property with constraints.
   */
  private generatePropertyValidation(
    prop: PropertyDefinition,
    indent: string
  ): string[] {
    const lines: string[] = [];
    const constraints = prop.constraints!;

    lines.push(`${indent}// Validate constraints on: ${prop.name}`);
    lines.push(`${indent}if (props.${prop.name} !== undefined && props.${prop.name} !== null) {`);

    // String length constraints
    if (constraints.minLength !== undefined || constraints.maxLength !== undefined) {
      lines.push(`${indent}  if (typeof props.${prop.name} === 'string') {`);

      if (constraints.minLength !== undefined) {
        lines.push(`${indent}    if (props.${prop.name}.length < ${constraints.minLength}) {`);
        lines.push(`${indent}      errors.push({`);
        lines.push(`${indent}        path: '${prop.name}',`);
        lines.push(`${indent}        message: 'Property "${prop.name}" must be at least ${constraints.minLength} characters',`);
        lines.push(`${indent}        code: 'STRING_TOO_SHORT',`);
        lines.push(`${indent}        fix: 'Provide a longer value for "${prop.name}"'`);
        lines.push(`${indent}      });`);
        lines.push(`${indent}    }`);
      }

      if (constraints.maxLength !== undefined) {
        lines.push(`${indent}    if (props.${prop.name}.length > ${constraints.maxLength}) {`);
        lines.push(`${indent}      errors.push({`);
        lines.push(`${indent}        path: '${prop.name}',`);
        lines.push(`${indent}        message: 'Property "${prop.name}" must be at most ${constraints.maxLength} characters',`);
        lines.push(`${indent}        code: 'STRING_TOO_LONG',`);
        lines.push(`${indent}        fix: 'Shorten the value of "${prop.name}" to ${constraints.maxLength} characters or less'`);
        lines.push(`${indent}      });`);
        lines.push(`${indent}    }`);
      }

      lines.push(`${indent}  }`);
    }

    // Numeric range constraints
    if (constraints.minimum !== undefined || constraints.maximum !== undefined) {
      lines.push(`${indent}  if (typeof props.${prop.name} === 'number') {`);

      if (constraints.minimum !== undefined) {
        lines.push(`${indent}    if (props.${prop.name} < ${constraints.minimum}) {`);
        lines.push(`${indent}      errors.push({`);
        lines.push(`${indent}        path: '${prop.name}',`);
        lines.push(`${indent}        message: 'Property "${prop.name}" must be at least ${constraints.minimum}',`);
        lines.push(`${indent}        code: 'VALUE_TOO_SMALL',`);
        lines.push(`${indent}        fix: 'Increase the value of "${prop.name}" to ${constraints.minimum} or greater'`);
        lines.push(`${indent}      });`);
        lines.push(`${indent}    }`);
      }

      if (constraints.maximum !== undefined) {
        lines.push(`${indent}    if (props.${prop.name} > ${constraints.maximum}) {`);
        lines.push(`${indent}      errors.push({`);
        lines.push(`${indent}        path: '${prop.name}',`);
        lines.push(`${indent}        message: 'Property "${prop.name}" must be at most ${constraints.maximum}',`);
        lines.push(`${indent}        code: 'VALUE_TOO_LARGE',`);
        lines.push(`${indent}        fix: 'Decrease the value of "${prop.name}" to ${constraints.maximum} or less'`);
        lines.push(`${indent}      });`);
        lines.push(`${indent}    }`);
      }

      lines.push(`${indent}  }`);
    }

    // Pattern constraints
    if (constraints.pattern) {
      const escapedPattern = constraints.pattern.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
      lines.push(`${indent}  if (typeof props.${prop.name} === 'string') {`);
      lines.push(`${indent}    const pattern = new RegExp('${escapedPattern}');`);
      lines.push(`${indent}    if (!pattern.test(props.${prop.name})) {`);
      lines.push(`${indent}      errors.push({`);
      lines.push(`${indent}        path: '${prop.name}',`);
      lines.push(`${indent}        message: 'Property "${prop.name}" does not match required pattern',`);
      lines.push(`${indent}        code: 'PATTERN_MISMATCH',`);
      lines.push(`${indent}        fix: 'Ensure "${prop.name}" matches the pattern: ${escapedPattern}'`);
      lines.push(`${indent}      });`);
      lines.push(`${indent}    }`);
      lines.push(`${indent}  }`);
    }

    // Enum constraints
    if (constraints.enum && constraints.enum.length > 0) {
      const enumValues = constraints.enum.map(v => `'${v}'`).join(', ');
      lines.push(`${indent}  const allowedValues = [${enumValues}];`);
      lines.push(`${indent}  if (!allowedValues.includes(props.${prop.name})) {`);
      lines.push(`${indent}    errors.push({`);
      lines.push(`${indent}      path: '${prop.name}',`);
      lines.push(`${indent}      message: 'Property "${prop.name}" must be one of: ${enumValues}',`);
      lines.push(`${indent}      code: 'INVALID_ENUM_VALUE',`);
      lines.push(`${indent}      fix: 'Use one of the allowed values: ${enumValues}'`);
      lines.push(`${indent}    });`);
      lines.push(`${indent}  }`);
    }

    lines.push(`${indent}}`);
    lines.push('');

    return lines;
  }

  /**
   * Convert name to PascalCase.
   */
  private toPascalCase(name: string): string {
    if (/^[A-Z]/.test(name)) {
      return name;
    }

    return name
      .split(/[_\-\/]/)
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join('');
  }
}
