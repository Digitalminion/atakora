/**
 * TypeScript Type Generator - Generates TypeScript interfaces from ARM schema IR.
 *
 * @packageDocumentation
 */

import * as path from 'path';
import type {
  SchemaIR,
  ResourceDefinition,
  PropertyDefinition,
  TypeDefinition,
} from './types';

/**
 * Generates TypeScript interface code from schema IR.
 *
 * @remarks
 * Produces clean, well-documented TypeScript interfaces matching
 * the existing hand-written type patterns in the codebase.
 *
 * @example
 * ```typescript
 * const parser = new SchemaParser();
 * const ir = parser.parse('path/to/schema.json');
 *
 * const generator = new TypeGenerator();
 * const code = generator.generate(ir);
 *
 * fs.writeFileSync('generated-types.ts', code);
 * ```
 */
export class TypeGenerator {
  /**
   * Generate TypeScript types file from schema IR.
   *
   * @param ir - Schema intermediate representation
   * @returns Generated TypeScript code
   */
  public generate(ir: SchemaIR): string {
    const lines: string[] = [];

    // File header
    lines.push(this.generateFileHeader(ir.metadata));
    lines.push('');

    // Generate shared type definitions first
    const generatedTypes = new Set<string>();

    for (const [name, typeDef] of ir.definitions) {
      if (typeDef.kind === 'object' && typeDef.properties) {
        const typeName = this.toTypeName(name);
        if (!generatedTypes.has(typeName)) {
          lines.push(this.generateInterface(name, typeDef));
          lines.push('');
          generatedTypes.add(typeName);
        }
      }
    }

    // Generate resource prop interfaces
    for (const resource of ir.resources) {
      lines.push(this.generateResourcePropsInterface(resource, ir));
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate file header with metadata and documentation.
   *
   * @param metadata - Schema metadata
   * @returns Header comment block
   */
  private generateFileHeader(metadata: any): string {
    return `/**
 * Type definitions for ${metadata.provider} resources.
 *
 * **API Version**: ${metadata.apiVersion}
 * **Generated**: ${metadata.generatedAt}
 * **Source**: ${path.basename(metadata.schemaPath)}
 *
 * @remarks
 * This file is auto-generated. Do not edit manually.
 * Generated by Felix (Schema & Validation Engineer)
 *
 * @packageDocumentation
 */`;
  }

  /**
   * Generate TypeScript interface for shared type definition.
   *
   * @param name - Type definition name
   * @param typeDef - Type definition
   * @returns Generated interface code
   */
  private generateInterface(name: string, typeDef: TypeDefinition): string {
    const lines: string[] = [];
    const typeName = this.toTypeName(name);

    // Interface JSDoc
    lines.push(`/**`);
    lines.push(` * ${typeName} definition.`);
    lines.push(` */`);

    // Interface declaration
    lines.push(`export interface ${typeName} {`);

    // Properties
    if (typeDef.properties) {
      for (const prop of typeDef.properties) {
        lines.push(this.generatePropertyDoc(prop, '  '));
        lines.push(this.generatePropertyDeclaration(prop, '  '));
      }
    }

    lines.push(`}`);

    return lines.join('\n');
  }

  /**
   * Generate resource props interface for L1 construct.
   *
   * @param resource - Resource definition
   * @param ir - Schema IR (for metadata)
   * @returns Generated interface code
   */
  private generateResourcePropsInterface(
    resource: ResourceDefinition,
    ir: SchemaIR
  ): string {
    const lines: string[] = [];
    const propsName = `Arm${this.toPascalCase(resource.name)}Props`;

    // Interface JSDoc with full documentation
    lines.push(`/**`);
    lines.push(` * Properties for ${resource.armType} (L1 construct).`);
    lines.push(` *`);

    if (resource.description) {
      lines.push(` * @remarks`);
      lines.push(` * ${resource.description}`);
      lines.push(` *`);
    }

    lines.push(` * **ARM Resource Type**: \`${resource.armType}\``);
    lines.push(` * **API Version**: \`${ir.apiVersion}\``);
    lines.push(` *`);
    lines.push(
      ` * Direct mapping to ARM resource properties with no defaults or transformations.`
    );
    lines.push(` */`);

    // Interface declaration
    lines.push(`export interface ${propsName} {`);

    // Properties
    for (const prop of resource.properties) {
      // Skip ARM metadata properties (type, apiVersion handled automatically)
      if (['type', 'apiVersion', 'resources'].includes(prop.name)) {
        continue;
      }

      lines.push(this.generatePropertyDoc(prop, '  '));
      lines.push(this.generatePropertyDeclaration(prop, '  '));
    }

    lines.push(`}`);

    return lines.join('\n');
  }

  /**
   * Generate JSDoc comment for a property.
   *
   * @param prop - Property definition
   * @param indent - Indentation string
   * @returns JSDoc comment block
   */
  private generatePropertyDoc(
    prop: PropertyDefinition,
    indent: string
  ): string {
    const lines: string[] = [];

    lines.push(`${indent}/**`);

    if (prop.description) {
      // Split description into lines if needed
      const descLines = prop.description.split('\n');
      for (const line of descLines) {
        lines.push(`${indent} * ${line}`);
      }
    } else {
      lines.push(`${indent} * ${prop.name}`);
    }

    // Add constraints to documentation
    if (prop.constraints) {
      lines.push(`${indent} *`);
      lines.push(`${indent} * @remarks`);

      if (
        prop.constraints.minLength !== undefined ||
        prop.constraints.maxLength !== undefined
      ) {
        const min = prop.constraints.minLength ?? 0;
        const max = prop.constraints.maxLength ?? 'unlimited';
        lines.push(`${indent} * Length: ${min}-${max} characters`);
      }

      if (prop.constraints.pattern) {
        lines.push(`${indent} * Pattern: \`${prop.constraints.pattern}\``);
      }

      if (
        prop.constraints.minimum !== undefined ||
        prop.constraints.maximum !== undefined
      ) {
        const min = prop.constraints.minimum ?? '-∞';
        const max = prop.constraints.maximum ?? '∞';
        lines.push(`${indent} * Range: ${min} to ${max}`);
      }
    }

    lines.push(`${indent} */`);

    return lines.join('\n');
  }

  /**
   * Generate TypeScript property declaration.
   *
   * @param prop - Property definition
   * @param indent - Indentation string
   * @returns Property declaration line
   */
  private generatePropertyDeclaration(
    prop: PropertyDefinition,
    indent: string
  ): string {
    const optional = prop.required ? '' : '?';
    return `${indent}readonly ${prop.name}${optional}: ${prop.type.tsType};`;
  }

  /**
   * Convert name to PascalCase for type names.
   *
   * @param name - Original name
   * @returns PascalCase name
   */
  private toPascalCase(name: string): string {
    // Handle already PascalCase names
    if (/^[A-Z]/.test(name)) {
      return name;
    }

    // Split on various separators and capitalize
    return name
      .split(/[_\-\/]/)
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join('');
  }

  /**
   * Convert definition name to TypeScript type name.
   *
   * @param name - Definition name from schema
   * @returns Clean TypeScript type name
   */
  private toTypeName(name: string): string {
    // Remove common ARM suffixes
    return name
      .replace(/PropertiesFormat$/, '')
      .replace(/Format$/, '')
      .replace(/Properties$/, 'Props');
  }
}
