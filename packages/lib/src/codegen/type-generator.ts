/**
 * TypeScript Type Generator - Generates TypeScript interfaces from ARM schema IR.
 *
 * @packageDocumentation
 */

import * as path from 'path';
import type {
  SchemaIR,
  ResourceDefinition,
  PropertyDefinition,
  TypeDefinition,
} from './types';

/**
 * Generates TypeScript interface code from schema IR.
 *
 * @remarks
 * Produces clean, well-documented TypeScript interfaces matching
 * the existing hand-written type patterns in the codebase.
 *
 * @example
 * ```typescript
 * const parser = new SchemaParser();
 * const ir = parser.parse('path/to/schema.json');
 *
 * const generator = new TypeGenerator();
 * const code = generator.generate(ir);
 *
 * fs.writeFileSync('generated-types.ts', code);
 * ```
 */
export class TypeGenerator {
  /**
   * Generate TypeScript types file from schema IR.
   *
   * @param ir - Schema intermediate representation
   * @returns Generated TypeScript code
   * @throws {Error} If referenced types are not defined
   */
  public generate(ir: SchemaIR): string {
    const lines: string[] = [];

    // File header
    lines.push(this.generateFileHeader(ir.metadata));
    lines.push('');

    // Generate shared type definitions first
    const generatedTypes = new Set<string>();
    const referencedTypes = new Set<string>();

    for (const [name, typeDef] of ir.definitions) {
      const typeName = this.toTypeName(name);

      // Track this type as "generated" (available for reference)
      // even if we don't emit an interface for it
      generatedTypes.add(typeName);

      // Generate type definitions based on kind
      if (typeDef.kind === 'object' && typeDef.properties) {
        // Object type with properties - generate interface
        if (!lines.includes(`export interface ${typeName}`)) {
          lines.push(this.generateInterface(name, typeDef));
          lines.push('');
        }
      } else if (typeDef.kind === 'union') {
        // Union type - generate type alias
        if (!lines.includes(`export type ${typeName}`)) {
          lines.push(this.generateTypeAlias(name, typeDef));
          lines.push('');
        }
      }

      // Track any type references in this definition
      this.collectTypeReferences(typeDef, referencedTypes);
    }

    // Generate resource prop interfaces
    for (const resource of ir.resources) {
      lines.push(this.generateResourcePropsInterface(resource, ir));
      lines.push('');

      // Track references in resource properties
      for (const prop of resource.properties) {
        this.collectTypeReferences(prop.type, referencedTypes);
      }
    }

    // Validate all referenced types are defined
    this.validateTypeReferences(generatedTypes, referencedTypes, ir.metadata);

    return lines.join('\n');
  }

  /**
   * Generate file header with metadata and documentation.
   *
   * @param metadata - Schema metadata
   * @returns Header comment block
   */
  private generateFileHeader(metadata: any): string {
    return `/**
 * Type definitions for ${metadata.provider} resources.
 *
 * **API Version**: ${metadata.apiVersion}
 * **Generated**: ${metadata.generatedAt}
 * **Source**: ${path.basename(metadata.schemaPath)}
 *
 * @remarks
 * This file is auto-generated. Do not edit manually.
 * Generated by Felix (Schema & Validation Engineer)
 *
 * @packageDocumentation
 */`;
  }

  /**
   * Generate TypeScript type alias for union types.
   *
   * @param name - Type definition name
   * @param typeDef - Type definition
   * @returns Generated type alias code
   */
  private generateTypeAlias(name: string, typeDef: TypeDefinition): string {
    const lines: string[] = [];
    const typeName = this.toTypeName(name);

    // Type alias JSDoc
    lines.push(`/**`);
    lines.push(` * ${typeName} type.`);
    lines.push(` */`);

    // Type alias declaration
    lines.push(`export type ${typeName} = ${typeDef.tsType};`);

    return lines.join('\n');
  }

  /**
   * Generate TypeScript interface for shared type definition.
   *
   * @param name - Type definition name
   * @param typeDef - Type definition
   * @returns Generated interface code
   */
  private generateInterface(name: string, typeDef: TypeDefinition): string {
    const lines: string[] = [];
    const typeName = this.toTypeName(name);

    // Interface JSDoc
    lines.push(`/**`);
    lines.push(` * ${typeName} definition.`);
    lines.push(` */`);

    // Interface declaration
    lines.push(`export interface ${typeName} {`);

    // Properties
    if (typeDef.properties) {
      for (const prop of typeDef.properties) {
        lines.push(this.generatePropertyDoc(prop, '  '));
        lines.push(this.generatePropertyDeclaration(prop, '  '));
      }
    }

    lines.push(`}`);

    return lines.join('\n');
  }

  /**
   * Generate resource props interface for L1 construct.
   *
   * @param resource - Resource definition
   * @param ir - Schema IR (for metadata)
   * @returns Generated interface code
   */
  private generateResourcePropsInterface(
    resource: ResourceDefinition,
    ir: SchemaIR
  ): string {
    const lines: string[] = [];
    const propsName = `Arm${this.toPascalCase(resource.name)}Props`;

    // Interface JSDoc with full documentation
    lines.push(`/**`);
    lines.push(` * Properties for ${resource.armType} (L1 construct).`);
    lines.push(` *`);

    if (resource.description) {
      lines.push(` * @remarks`);
      lines.push(` * ${resource.description}`);
      lines.push(` *`);
    }

    lines.push(` * **ARM Resource Type**: \`${resource.armType}\``);
    lines.push(` * **API Version**: \`${ir.apiVersion}\``);
    lines.push(` *`);
    lines.push(
      ` * Direct mapping to ARM resource properties with no defaults or transformations.`
    );
    lines.push(` */`);

    // Interface declaration
    lines.push(`export interface ${propsName} {`);

    // Properties
    for (const prop of resource.properties) {
      // Skip ARM metadata properties (type, apiVersion handled automatically)
      if (['type', 'apiVersion', 'resources'].includes(prop.name)) {
        continue;
      }

      lines.push(this.generatePropertyDoc(prop, '  '));
      lines.push(this.generatePropertyDeclaration(prop, '  '));
    }

    lines.push(`}`);

    return lines.join('\n');
  }

  /**
   * Generate JSDoc comment for a property.
   *
   * @param prop - Property definition
   * @param indent - Indentation string
   * @returns JSDoc comment block
   */
  private generatePropertyDoc(
    prop: PropertyDefinition,
    indent: string
  ): string {
    const lines: string[] = [];

    lines.push(`${indent}/**`);

    if (prop.description) {
      // Split description into lines if needed
      const descLines = prop.description.split('\n');
      for (const line of descLines) {
        lines.push(`${indent} * ${line}`);
      }
    } else {
      lines.push(`${indent} * ${prop.name}`);
    }

    // Add constraints to documentation
    if (prop.constraints) {
      lines.push(`${indent} *`);
      lines.push(`${indent} * @remarks`);

      if (
        prop.constraints.minLength !== undefined ||
        prop.constraints.maxLength !== undefined
      ) {
        const min = prop.constraints.minLength ?? 0;
        const max = prop.constraints.maxLength ?? 'unlimited';
        lines.push(`${indent} * Length: ${min}-${max} characters`);
      }

      if (prop.constraints.pattern) {
        lines.push(`${indent} * Pattern: \`${prop.constraints.pattern}\``);
      }

      if (
        prop.constraints.minimum !== undefined ||
        prop.constraints.maximum !== undefined
      ) {
        const min = prop.constraints.minimum ?? '-∞';
        const max = prop.constraints.maximum ?? '∞';
        lines.push(`${indent} * Range: ${min} to ${max}`);
      }
    }

    lines.push(`${indent} */`);

    return lines.join('\n');
  }

  /**
   * Generate TypeScript property declaration.
   *
   * @param prop - Property definition
   * @param indent - Indentation string
   * @returns Property declaration line
   */
  private generatePropertyDeclaration(
    prop: PropertyDefinition,
    indent: string
  ): string {
    const optional = prop.required ? '' : '?';
    return `${indent}readonly ${prop.name}${optional}: ${prop.type.tsType};`;
  }

  /**
   * Convert name to PascalCase for type names.
   *
   * @param name - Original name
   * @returns PascalCase name
   */
  private toPascalCase(name: string): string {
    // Handle already PascalCase names
    if (/^[A-Z]/.test(name)) {
      return name;
    }

    // Split on various separators and capitalize
    return name
      .split(/[_\-\/]/)
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join('');
  }

  /**
   * Convert definition name to TypeScript type name.
   *
   * @param name - Definition name from schema
   * @returns Clean TypeScript type name
   */
  private toTypeName(name: string): string {
    // Remove common ARM suffixes
    return name
      .replace(/PropertiesFormat$/, '')
      .replace(/Format$/, '')
      .replace(/Properties$/, 'Props');
  }

  /**
   * Collect all type references from a type definition.
   *
   * @param typeDef - Type definition to scan
   * @param referencedTypes - Set to collect references into
   */
  private collectTypeReferences(
    typeDef: TypeDefinition,
    referencedTypes: Set<string>
  ): void {
    if (typeDef.kind === 'reference') {
      // Add the actual tsType which has been transformed
      referencedTypes.add(typeDef.tsType);
    } else if (typeDef.kind === 'array' && typeDef.elementType) {
      this.collectTypeReferences(typeDef.elementType, referencedTypes);
    } else if (typeDef.kind === 'union' && typeDef.unionTypes) {
      for (const unionType of typeDef.unionTypes) {
        this.collectTypeReferences(unionType, referencedTypes);
      }
    } else if (typeDef.kind === 'object' && typeDef.properties) {
      for (const prop of typeDef.properties) {
        this.collectTypeReferences(prop.type, referencedTypes);
      }
    }
  }

  /**
   * Validate that all referenced types are actually defined.
   *
   * @param generatedTypes - Set of types that were generated
   * @param referencedTypes - Set of types that were referenced
   * @param metadata - Schema metadata for error messages
   * @throws {Error} If any referenced type is not defined
   */
  private validateTypeReferences(
    generatedTypes: Set<string>,
    referencedTypes: Set<string>,
    metadata: any
  ): void {
    const missingTypes: string[] = [];

    for (const refType of referencedTypes) {
      // Skip primitive types and common TypeScript types
      const primitives = ['string', 'number', 'boolean', 'any', 'object'];
      const isPrimitive = primitives.some((p) => refType.includes(p));
      const isRecord = refType.startsWith('Record<');
      const isArray = refType.endsWith('[]');

      if (isPrimitive || isRecord || isArray) {
        continue;
      }

      // Check if the referenced type was generated
      if (!generatedTypes.has(refType)) {
        missingTypes.push(refType);
      }
    }

    if (missingTypes.length > 0) {
      const errorMsg = [
        `Type generation validation failed for ${metadata.provider}:`,
        ``,
        `The following types are referenced but not defined:`,
        ...missingTypes.map((t) => `  - ${t}`),
        ``,
        `This indicates either:`,
        `  1. Missing definitions in the ARM schema`,
        `  2. A bug in the type name transformation logic`,
        `  3. External type references that need to be imported`,
        ``,
        `Please review the schema and type generation logic.`,
      ].join('\n');

      throw new Error(errorMsg);
    }
  }
}
