/**
 * Runtime validators for Microsoft.DBforMySQL resources.
 *
 * **API Version**: 2024-12-01-preview
 * **Generated**: 2025-10-13T00:00:00.000Z
 *
 * @remarks
 * This file is auto-generated. Do not edit manually.
 * Generated by Felix (Schema & Validation Engineer)
 *
 * @packageDocumentation
 */

/**
 * Validation error.
 */
export interface ValidationError {
  readonly path: string;
  readonly message: string;
  readonly code: string;
  readonly fix?: string;
}

/**
 * Validation result.
 */
export interface ValidationResult {
  readonly valid: boolean;
  readonly errors: ValidationError[];
}

/**
 * Validate flexible server name format.
 *
 * @param name - Server name to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateFlexibleServerName(name: string, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!name) {
    errors.push({
      path,
      message: 'Server name is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide a server name',
    });
    return errors;
  }

  if (name.length < 1 || name.length > 63) {
    errors.push({
      path,
      message: `Server name length must be between 1 and 63 characters, got ${name.length}`,
      code: 'INVALID_LENGTH',
      fix: 'Use a server name between 1 and 63 characters',
    });
  }

  const namePattern = /^[a-z0-9][-a-z0-9]*(?<!-)$/;
  if (!namePattern.test(name)) {
    errors.push({
      path,
      message: `Server name must start with alphanumeric, contain only lowercase letters, numbers, and hyphens, and cannot end with a hyphen. Got: "${name}"`,
      code: 'INVALID_PATTERN',
      fix: 'Use only lowercase letters, numbers, and hyphens. Start with alphanumeric and do not end with a hyphen',
    });
  }

  return errors;
}

/**
 * Validate IP address format.
 *
 * @param ip - IP address to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateIpAddress(ip: string, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!ip) {
    errors.push({
      path,
      message: 'IP address is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide an IP address',
    });
    return errors;
  }

  const ipPattern = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (!ipPattern.test(ip)) {
    errors.push({
      path,
      message: `Invalid IPv4 address format: "${ip}"`,
      code: 'INVALID_IP_FORMAT',
      fix: 'Use valid IPv4 format (e.g., "192.168.1.1")',
    });
    return errors;
  }

  const octets = ip.split('.');
  for (let i = 0; i < octets.length; i++) {
    const octet = parseInt(octets[i], 10);
    if (octet < 0 || octet > 255) {
      errors.push({
        path,
        message: `IP address octet must be between 0 and 255, got ${octet} in "${ip}"`,
        code: 'INVALID_IP_OCTET',
        fix: 'Ensure each octet is between 0 and 255',
      });
      break;
    }
  }

  return errors;
}

/**
 * Validate ISO 8601 date-time format.
 *
 * @param dateTime - Date-time string to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateIso8601DateTime(dateTime: string, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!dateTime) {
    errors.push({
      path,
      message: 'Date-time is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide an ISO 8601 date-time string',
    });
    return errors;
  }

  const iso8601Pattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:\d{2})$/;
  if (!iso8601Pattern.test(dateTime)) {
    errors.push({
      path,
      message: `Invalid ISO 8601 date-time format: "${dateTime}"`,
      code: 'INVALID_DATETIME_FORMAT',
      fix: 'Use ISO 8601 format (e.g., "2024-10-13T12:00:00Z")',
    });
    return errors;
  }

  const date = new Date(dateTime);
  if (isNaN(date.getTime())) {
    errors.push({
      path,
      message: `Invalid date-time value: "${dateTime}"`,
      code: 'INVALID_DATETIME_VALUE',
      fix: 'Provide a valid date-time',
    });
  }

  return errors;
}

/**
 * Validate MySQL SKU.
 *
 * @param sku - SKU to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateSku(sku: any, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!sku) {
    errors.push({
      path,
      message: 'SKU is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide a SKU configuration',
    });
    return errors;
  }

  if (!sku.name) {
    errors.push({
      path: `${path}.name`,
      message: 'SKU name is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide a SKU name (e.g., "Standard_B1s", "Standard_D2ds_v4")',
    });
  }

  if (!sku.tier) {
    errors.push({
      path: `${path}.tier`,
      message: 'SKU tier is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide a SKU tier (Burstable, GeneralPurpose, or MemoryOptimized)',
    });
  } else {
    const validTiers = ['Burstable', 'GeneralPurpose', 'MemoryOptimized'];
    if (!validTiers.includes(sku.tier)) {
      errors.push({
        path: `${path}.tier`,
        message: `SKU tier must be one of: ${validTiers.join(', ')}. Got: "${sku.tier}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validTiers.join(', ')}`,
      });
    }
  }

  return errors;
}

/**
 * Validate backup configuration.
 *
 * @param backup - Backup configuration to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateBackup(backup: any, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!backup) {
    return errors;
  }

  if (backup.backupRetentionDays !== undefined) {
    const days = backup.backupRetentionDays;
    if (typeof days !== 'number' || days < 1 || days > 35) {
      errors.push({
        path: `${path}.backupRetentionDays`,
        message: `Backup retention days must be between 1 and 35, got ${days}`,
        code: 'VALUE_OUT_OF_RANGE',
        fix: 'Set backup retention between 1 and 35 days',
      });
    }
  }

  const validGeoRedundantValues = ['Disabled', 'Enabled'];
  if (backup.geoRedundantBackup !== undefined) {
    if (!validGeoRedundantValues.includes(backup.geoRedundantBackup)) {
      errors.push({
        path: `${path}.geoRedundantBackup`,
        message: `Geo-redundant backup must be one of: ${validGeoRedundantValues.join(', ')}. Got: "${backup.geoRedundantBackup}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validGeoRedundantValues.join(', ')}`,
      });
    }
  }

  return errors;
}

/**
 * Validate storage configuration.
 *
 * @param storage - Storage configuration to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateStorage(storage: any, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!storage) {
    return errors;
  }

  if (storage.storageSizeGB !== undefined) {
    const sizeGB = storage.storageSizeGB;
    if (typeof sizeGB !== 'number' || sizeGB < 20 || sizeGB > 16384) {
      errors.push({
        path: `${path}.storageSizeGB`,
        message: `Storage size must be between 20 GB and 16384 GB (16 TB), got ${sizeGB}`,
        code: 'VALUE_OUT_OF_RANGE',
        fix: 'Set storage size between 20 GB and 16384 GB',
      });
    }
  }

  const validAutoGrowValues = ['Disabled', 'Enabled'];
  if (storage.autoGrow !== undefined) {
    if (!validAutoGrowValues.includes(storage.autoGrow)) {
      errors.push({
        path: `${path}.autoGrow`,
        message: `Storage auto-grow must be one of: ${validAutoGrowValues.join(', ')}. Got: "${storage.autoGrow}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validAutoGrowValues.join(', ')}`,
      });
    }
  }

  const validAutoIoScalingValues = ['Disabled', 'Enabled'];
  if (storage.autoIoScaling !== undefined) {
    if (!validAutoIoScalingValues.includes(storage.autoIoScaling)) {
      errors.push({
        path: `${path}.autoIoScaling`,
        message: `Storage auto IO scaling must be one of: ${validAutoIoScalingValues.join(', ')}. Got: "${storage.autoIoScaling}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validAutoIoScalingValues.join(', ')}`,
      });
    }
  }

  const validLogOnDiskValues = ['Disabled', 'Enabled'];
  if (storage.logOnDisk !== undefined) {
    if (!validLogOnDiskValues.includes(storage.logOnDisk)) {
      errors.push({
        path: `${path}.logOnDisk`,
        message: `Log on disk must be one of: ${validLogOnDiskValues.join(', ')}. Got: "${storage.logOnDisk}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validLogOnDiskValues.join(', ')}`,
      });
    }
  }

  const validStorageRedundancyValues = ['LocalRedundancy', 'ZoneRedundancy'];
  if (storage.storageRedundancy !== undefined) {
    if (!validStorageRedundancyValues.includes(storage.storageRedundancy)) {
      errors.push({
        path: `${path}.storageRedundancy`,
        message: `Storage redundancy must be one of: ${validStorageRedundancyValues.join(', ')}. Got: "${storage.storageRedundancy}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validStorageRedundancyValues.join(', ')}`,
      });
    }
  }

  return errors;
}

/**
 * Validate network configuration.
 *
 * @param network - Network configuration to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateNetwork(network: any, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!network) {
    return errors;
  }

  const validPublicNetworkAccessValues = ['Disabled', 'Enabled'];
  if (network.publicNetworkAccess !== undefined) {
    if (!validPublicNetworkAccessValues.includes(network.publicNetworkAccess)) {
      errors.push({
        path: `${path}.publicNetworkAccess`,
        message: `Public network access must be one of: ${validPublicNetworkAccessValues.join(', ')}. Got: "${network.publicNetworkAccess}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validPublicNetworkAccessValues.join(', ')}`,
      });
    }
  }

  return errors;
}

/**
 * Validate high availability configuration.
 *
 * @param highAvailability - High availability configuration to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateHighAvailability(highAvailability: any, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!highAvailability) {
    return errors;
  }

  const validModes = ['Disabled', 'SameZone', 'ZoneRedundant'];
  if (highAvailability.mode !== undefined) {
    if (!validModes.includes(highAvailability.mode)) {
      errors.push({
        path: `${path}.mode`,
        message: `High availability mode must be one of: ${validModes.join(', ')}. Got: "${highAvailability.mode}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validModes.join(', ')}`,
      });
    }
  }

  return errors;
}

/**
 * Validate maintenance window configuration.
 *
 * @param maintenanceWindow - Maintenance window configuration to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateMaintenanceWindow(maintenanceWindow: any, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!maintenanceWindow) {
    return errors;
  }

  if (maintenanceWindow.dayOfWeek !== undefined) {
    const day = maintenanceWindow.dayOfWeek;
    if (typeof day !== 'number' || day < 0 || day > 6) {
      errors.push({
        path: `${path}.dayOfWeek`,
        message: `Day of week must be between 0 (Sunday) and 6 (Saturday), got ${day}`,
        code: 'VALUE_OUT_OF_RANGE',
        fix: 'Set day of week between 0 and 6',
      });
    }
  }

  if (maintenanceWindow.startHour !== undefined) {
    const hour = maintenanceWindow.startHour;
    if (typeof hour !== 'number' || hour < 0 || hour > 23) {
      errors.push({
        path: `${path}.startHour`,
        message: `Start hour must be between 0 and 23, got ${hour}`,
        code: 'VALUE_OUT_OF_RANGE',
        fix: 'Set start hour between 0 and 23',
      });
    }
  }

  if (maintenanceWindow.startMinute !== undefined) {
    const minute = maintenanceWindow.startMinute;
    if (typeof minute !== 'number' || minute < 0 || minute > 59) {
      errors.push({
        path: `${path}.startMinute`,
        message: `Start minute must be between 0 and 59, got ${minute}`,
        code: 'VALUE_OUT_OF_RANGE',
        fix: 'Set start minute between 0 and 59',
      });
    }
  }

  return errors;
}

/**
 * Validate data encryption configuration.
 *
 * @param dataEncryption - Data encryption configuration to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateDataEncryption(dataEncryption: any, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!dataEncryption) {
    return errors;
  }

  const validTypes = ['AzureKeyVault', 'SystemManaged'];
  if (dataEncryption.type !== undefined) {
    if (!validTypes.includes(dataEncryption.type)) {
      errors.push({
        path: `${path}.type`,
        message: `Data encryption type must be one of: ${validTypes.join(', ')}. Got: "${dataEncryption.type}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validTypes.join(', ')}`,
      });
    }
  }

  if (dataEncryption.type === 'AzureKeyVault') {
    if (!dataEncryption.primaryKeyURI) {
      errors.push({
        path: `${path}.primaryKeyURI`,
        message: 'Primary key URI is required when using AzureKeyVault encryption',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Provide primaryKeyURI for Azure Key Vault encryption',
      });
    }

    if (!dataEncryption.primaryUserAssignedIdentityId) {
      errors.push({
        path: `${path}.primaryUserAssignedIdentityId`,
        message: 'Primary user-assigned identity ID is required when using AzureKeyVault encryption',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Provide primaryUserAssignedIdentityId for Azure Key Vault encryption',
      });
    }
  }

  return errors;
}

/**
 * Validate common server properties.
 *
 * @param properties - Server properties to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateCommonServerProperties(properties: any, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  const validVersions = ['5.7', '8.0.21'];
  if (properties.version !== undefined) {
    if (!validVersions.includes(properties.version)) {
      errors.push({
        path: `${path}.version`,
        message: `MySQL version must be one of: ${validVersions.join(', ')}. Got: "${properties.version}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validVersions.join(', ')}`,
      });
    }
  }

  const validReplicationRoles = ['None', 'Replica', 'Source'];
  if (properties.replicationRole !== undefined) {
    if (!validReplicationRoles.includes(properties.replicationRole)) {
      errors.push({
        path: `${path}.replicationRole`,
        message: `Replication role must be one of: ${validReplicationRoles.join(', ')}. Got: "${properties.replicationRole}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validReplicationRoles.join(', ')}`,
      });
    }
  }

  if (properties.backup) {
    errors.push(...validateBackup(properties.backup, `${path}.backup`));
  }

  if (properties.storage) {
    errors.push(...validateStorage(properties.storage, `${path}.storage`));
  }

  if (properties.network) {
    errors.push(...validateNetwork(properties.network, `${path}.network`));
  }

  if (properties.highAvailability) {
    errors.push(...validateHighAvailability(properties.highAvailability, `${path}.highAvailability`));
  }

  if (properties.maintenanceWindow) {
    errors.push(...validateMaintenanceWindow(properties.maintenanceWindow, `${path}.maintenanceWindow`));
  }

  if (properties.dataEncryption) {
    errors.push(...validateDataEncryption(properties.dataEncryption, `${path}.dataEncryption`));
  }

  return errors;
}

/**
 * Validate Microsoft.DBforMySQL/flexibleServers properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validateMySqlFlexibleServer(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required properties
  if (!props.name) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your resource definition',
    });
  } else {
    errors.push(...validateFlexibleServerName(props.name, 'name'));
  }

  if (!props.location) {
    errors.push({
      path: 'location',
      message: 'Required property "location" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "location" property (e.g., "eastus", "westeurope")',
    });
  }

  if (!props.sku) {
    errors.push({
      path: 'sku',
      message: 'Required property "sku" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "sku" object with name and tier',
    });
  } else {
    errors.push(...validateSku(props.sku, 'sku'));
  }

  if (!props.properties) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with server configuration',
    });
    return { valid: errors.length === 0, errors };
  }

  const properties = props.properties;

  if (!properties.createMode) {
    errors.push({
      path: 'properties.createMode',
      message: 'Required property "createMode" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add "createMode" property (Default, GeoRestore, PointInTimeRestore, or Replica)',
    });
    return { valid: errors.length === 0, errors };
  }

  // Validate based on create mode
  const validCreateModes = ['Default', 'GeoRestore', 'PointInTimeRestore', 'Replica'];
  if (!validCreateModes.includes(properties.createMode)) {
    errors.push({
      path: 'properties.createMode',
      message: `Create mode must be one of: ${validCreateModes.join(', ')}. Got: "${properties.createMode}"`,
      code: 'INVALID_ENUM_VALUE',
      fix: `Use one of: ${validCreateModes.join(', ')}`,
    });
    return { valid: errors.length === 0, errors };
  }

  // Validate common properties
  errors.push(...validateCommonServerProperties(properties, 'properties'));

  // Validate mode-specific properties
  switch (properties.createMode) {
    case 'Default':
      if (!properties.administratorLogin) {
        errors.push({
          path: 'properties.administratorLogin',
          message: 'Administrator login is required for Default create mode',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "administratorLogin" property with a valid username',
        });
      } else {
        if (properties.administratorLogin.length < 1 || properties.administratorLogin.length > 16) {
          errors.push({
            path: 'properties.administratorLogin',
            message: `Administrator login length must be between 1 and 16 characters, got ${properties.administratorLogin.length}`,
            code: 'INVALID_LENGTH',
            fix: 'Use an administrator login between 1 and 16 characters',
          });
        }

        const invalidUsernames = ['azure_superuser', 'admin', 'administrator', 'root', 'guest', 'public'];
        if (invalidUsernames.includes(properties.administratorLogin.toLowerCase())) {
          errors.push({
            path: 'properties.administratorLogin',
            message: `Administrator login cannot be: ${invalidUsernames.join(', ')}. Got: "${properties.administratorLogin}"`,
            code: 'INVALID_VALUE',
            fix: 'Use a different administrator username',
          });
        }
      }

      if (!properties.administratorLoginPassword) {
        errors.push({
          path: 'properties.administratorLoginPassword',
          message: 'Administrator login password is required for Default create mode',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "administratorLoginPassword" property with a strong password (8-128 characters)',
        });
      } else {
        const password = properties.administratorLoginPassword;
        if (password.length < 8 || password.length > 128) {
          errors.push({
            path: 'properties.administratorLoginPassword',
            message: `Administrator password length must be between 8 and 128 characters, got ${password.length}`,
            code: 'INVALID_LENGTH',
            fix: 'Use a password between 8 and 128 characters',
          });
        }
      }
      break;

    case 'GeoRestore':
      if (!properties.sourceServerResourceId) {
        errors.push({
          path: 'properties.sourceServerResourceId',
          message: 'Source server resource ID is required for GeoRestore create mode',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "sourceServerResourceId" property with the resource ID of the source server',
        });
      }

      if (properties.pointInTimeUTC) {
        errors.push(...validateIso8601DateTime(properties.pointInTimeUTC, 'properties.pointInTimeUTC'));
      }
      break;

    case 'PointInTimeRestore':
      if (!properties.sourceServerResourceId) {
        errors.push({
          path: 'properties.sourceServerResourceId',
          message: 'Source server resource ID is required for PointInTimeRestore create mode',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "sourceServerResourceId" property with the resource ID of the source server',
        });
      }

      if (!properties.pointInTimeUTC) {
        errors.push({
          path: 'properties.pointInTimeUTC',
          message: 'Point in time UTC is required for PointInTimeRestore create mode',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "pointInTimeUTC" property with an ISO 8601 date-time string',
        });
      } else {
        errors.push(...validateIso8601DateTime(properties.pointInTimeUTC, 'properties.pointInTimeUTC'));
      }
      break;

    case 'Replica':
      if (!properties.sourceServerResourceId) {
        errors.push({
          path: 'properties.sourceServerResourceId',
          message: 'Source server resource ID is required for Replica create mode',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "sourceServerResourceId" property with the resource ID of the source server',
        });
      }
      break;
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate Microsoft.DBforMySQL/flexibleServers/databases properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validateMySqlDatabase(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  if (!props.name) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your database definition',
    });
  } else {
    if (props.name.length < 1 || props.name.length > 64) {
      errors.push({
        path: 'name',
        message: `Database name length must be between 1 and 64 characters, got ${props.name.length}`,
        code: 'INVALID_LENGTH',
        fix: 'Use a database name between 1 and 64 characters',
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate Microsoft.DBforMySQL/flexibleServers/firewallRules properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validateMySqlFirewallRule(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  if (!props.name) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your firewall rule definition',
    });
  } else {
    if (props.name.length < 1 || props.name.length > 128) {
      errors.push({
        path: 'name',
        message: `Firewall rule name length must be between 1 and 128 characters, got ${props.name.length}`,
        code: 'INVALID_LENGTH',
        fix: 'Use a firewall rule name between 1 and 128 characters',
      });
    }
  }

  if (!props.properties) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with startIpAddress and endIpAddress',
    });
    return { valid: errors.length === 0, errors };
  }

  if (!props.properties.startIpAddress) {
    errors.push({
      path: 'properties.startIpAddress',
      message: 'Start IP address is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add "startIpAddress" property with a valid IPv4 address',
    });
  } else {
    errors.push(...validateIpAddress(props.properties.startIpAddress, 'properties.startIpAddress'));
  }

  if (!props.properties.endIpAddress) {
    errors.push({
      path: 'properties.endIpAddress',
      message: 'End IP address is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add "endIpAddress" property with a valid IPv4 address',
    });
  } else {
    errors.push(...validateIpAddress(props.properties.endIpAddress, 'properties.endIpAddress'));
  }

  // Validate IP range if both IPs are valid
  if (props.properties.startIpAddress && props.properties.endIpAddress) {
    const startErrors = validateIpAddress(props.properties.startIpAddress, 'properties.startIpAddress');
    const endErrors = validateIpAddress(props.properties.endIpAddress, 'properties.endIpAddress');

    if (startErrors.length === 0 && endErrors.length === 0) {
      const startOctets = props.properties.startIpAddress.split('.').map((o: string) => parseInt(o, 10));
      const endOctets = props.properties.endIpAddress.split('.').map((o: string) => parseInt(o, 10));

      const startValue = (startOctets[0] << 24) + (startOctets[1] << 16) + (startOctets[2] << 8) + startOctets[3];
      const endValue = (endOctets[0] << 24) + (endOctets[1] << 16) + (endOctets[2] << 8) + endOctets[3];

      if (startValue > endValue) {
        errors.push({
          path: 'properties',
          message: `Start IP address (${props.properties.startIpAddress}) must be less than or equal to end IP address (${props.properties.endIpAddress})`,
          code: 'INVALID_IP_RANGE',
          fix: 'Ensure startIpAddress is less than or equal to endIpAddress',
        });
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate Microsoft.DBforMySQL/flexibleServers/configurations properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validateMySqlConfiguration(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  if (!props.name) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your configuration definition',
    });
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
