/**
 * Runtime validators for Microsoft.OperationalInsights resources.
 *
 * **API Version**: 2023-09-01
 * **Generated**: 2025-10-13
 *
 * @remarks
 * This file is auto-generated. Do not edit manually.
 * Generated by Felix (Schema & Validation Engineer)
 *
 * @packageDocumentation
 */

/**
 * Validation error details.
 */
export interface ValidationError {
  readonly path: string;
  readonly message: string;
  readonly code: string;
  readonly fix?: string;
}

/**
 * Validation result.
 */
export interface ValidationResult {
  readonly valid: boolean;
  readonly errors: ValidationError[];
}

/**
 * Valid workspace SKU names.
 */
const VALID_WORKSPACE_SKUS = [
  'Free',
  'Standard',
  'Premium',
  'PerNode',
  'PerGB2018',
  'Standalone',
  'CapacityReservation',
  'LACluster',
] as const;

/**
 * Valid capacity reservation levels in GB per day.
 */
const VALID_CAPACITY_LEVELS = [100, 200, 300, 400, 500, 1000, 2000, 5000] as const;

/**
 * Valid public network access values.
 */
const VALID_PUBLIC_NETWORK_ACCESS = ['Enabled', 'Disabled'] as const;

/**
 * Valid identity types.
 */
const VALID_IDENTITY_TYPES = ['None', 'SystemAssigned', 'UserAssigned', 'SystemAssigned,UserAssigned'] as const;

/**
 * Validate workspace name.
 *
 * @param name - Workspace name to validate
 * @returns Validation errors if invalid
 */
function validateWorkspaceName(name: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!name) {
    errors.push({
      path: 'name',
      message: 'Workspace name is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide a workspace name',
    });
    return errors;
  }

  // Check length
  if (name.length < 4 || name.length > 63) {
    errors.push({
      path: 'name',
      message: `Workspace name must be 4-63 characters. Got ${name.length} characters: "${name}"`,
      code: 'INVALID_LENGTH',
      fix: 'Use a name between 4 and 63 characters',
    });
  }

  // Check pattern
  const pattern = /^[A-Za-z0-9][A-Za-z0-9-]+[A-Za-z0-9]$/;
  if (!pattern.test(name)) {
    errors.push({
      path: 'name',
      message: `Workspace name must start and end with alphanumeric, contain only letters, numbers, and hyphens. Got: "${name}"`,
      code: 'INVALID_PATTERN',
      fix: 'Use only letters (A-Z, a-z), numbers (0-9), and hyphens (-), starting and ending with alphanumeric',
    });
  }

  return errors;
}

/**
 * Validate workspace SKU.
 *
 * @param sku - SKU configuration to validate
 * @returns Validation errors if invalid
 */
function validateWorkspaceSku(sku: any): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!sku) {
    errors.push({
      path: 'properties.sku',
      message: 'SKU is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide a SKU configuration with a name property',
    });
    return errors;
  }

  if (!sku.name) {
    errors.push({
      path: 'properties.sku.name',
      message: 'SKU name is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: `Specify a SKU name. Valid values: ${VALID_WORKSPACE_SKUS.join(', ')}`,
    });
  } else if (!VALID_WORKSPACE_SKUS.includes(sku.name)) {
    errors.push({
      path: 'properties.sku.name',
      message: `Invalid SKU name: "${sku.name}". Must be one of: ${VALID_WORKSPACE_SKUS.join(', ')}`,
      code: 'INVALID_ENUM_VALUE',
      fix: `Use one of the valid SKU names: ${VALID_WORKSPACE_SKUS.join(', ')}`,
    });
  }

  // Validate capacity reservation level if provided
  if (sku.capacityReservationLevel !== undefined) {
    if (sku.name !== 'CapacityReservation') {
      errors.push({
        path: 'properties.sku.capacityReservationLevel',
        message: `Capacity reservation level can only be specified when SKU name is 'CapacityReservation'. Current SKU: "${sku.name}"`,
        code: 'INVALID_PROPERTY_COMBINATION',
        fix: 'Remove capacityReservationLevel or change SKU name to CapacityReservation',
      });
    } else if (!VALID_CAPACITY_LEVELS.includes(sku.capacityReservationLevel)) {
      errors.push({
        path: 'properties.sku.capacityReservationLevel',
        message: `Invalid capacity reservation level: ${sku.capacityReservationLevel}. Must be one of: ${VALID_CAPACITY_LEVELS.join(', ')}`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of the valid capacity levels: ${VALID_CAPACITY_LEVELS.join(', ')}`,
      });
    }
  } else if (sku.name === 'CapacityReservation') {
    errors.push({
      path: 'properties.sku.capacityReservationLevel',
      message: 'Capacity reservation level is required when SKU name is CapacityReservation',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: `Specify a capacity reservation level. Valid values: ${VALID_CAPACITY_LEVELS.join(', ')}`,
    });
  }

  return errors;
}

/**
 * Validate workspace capping configuration.
 *
 * @param capping - Capping configuration to validate
 * @returns Validation errors if invalid
 */
function validateWorkspaceCapping(capping: any): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!capping) {
    return errors;
  }

  if (capping.dailyQuotaGb !== undefined) {
    const quota = capping.dailyQuotaGb;
    const minQuota = 0.023;

    if (typeof quota !== 'number') {
      errors.push({
        path: 'properties.workspaceCapping.dailyQuotaGb',
        message: `Daily quota must be a number. Got: ${typeof quota}`,
        code: 'INVALID_TYPE',
        fix: 'Specify a numeric value for daily quota in GB',
      });
    } else if (quota !== -1 && quota < minQuota) {
      errors.push({
        path: 'properties.workspaceCapping.dailyQuotaGb',
        message: `Daily quota must be at least ${minQuota} GB or -1 for unlimited. Got: ${quota}`,
        code: 'INVALID_RANGE',
        fix: `Set daily quota to at least ${minQuota} GB, or use -1 for unlimited`,
      });
    }
  }

  return errors;
}

/**
 * Validate retention period.
 *
 * @param retentionInDays - Retention period to validate
 * @param skuName - SKU name for context
 * @returns Validation errors if invalid
 */
function validateRetention(retentionInDays: any, skuName: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (retentionInDays === undefined) {
    return errors;
  }

  if (typeof retentionInDays !== 'number' || !Number.isInteger(retentionInDays)) {
    errors.push({
      path: 'properties.retentionInDays',
      message: `Retention must be an integer. Got: ${retentionInDays}`,
      code: 'INVALID_TYPE',
      fix: 'Specify an integer value for retention in days',
    });
    return errors;
  }

  // Free tier has fixed 7-day retention
  if (skuName === 'Free') {
    if (retentionInDays !== 7) {
      errors.push({
        path: 'properties.retentionInDays',
        message: `Free tier must use 7-day retention. Got: ${retentionInDays} days`,
        code: 'INVALID_RANGE',
        fix: 'Set retention to 7 days for Free tier, or use a paid SKU for custom retention',
      });
    }
  } else {
    // Paid tiers: 30-730 days (can be extended to 4383 with dedicated cluster)
    if (retentionInDays < 30 || retentionInDays > 4383) {
      errors.push({
        path: 'properties.retentionInDays',
        message: `Retention must be 30-730 days for paid SKUs (up to 4383 with dedicated cluster). Got: ${retentionInDays} days`,
        code: 'INVALID_RANGE',
        fix: 'Set retention between 30 and 730 days (or up to 4383 days with a dedicated cluster)',
      });
    }
  }

  return errors;
}

/**
 * Validate public network access setting.
 *
 * @param value - Public network access value
 * @param path - Property path for error reporting
 * @returns Validation errors if invalid
 */
function validatePublicNetworkAccess(value: any, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (value !== undefined && !VALID_PUBLIC_NETWORK_ACCESS.includes(value)) {
    errors.push({
      path,
      message: `Invalid public network access value: "${value}". Must be one of: ${VALID_PUBLIC_NETWORK_ACCESS.join(', ')}`,
      code: 'INVALID_ENUM_VALUE',
      fix: `Use one of: ${VALID_PUBLIC_NETWORK_ACCESS.join(', ')}`,
    });
  }

  return errors;
}

/**
 * Validate workspace identity.
 *
 * @param identity - Identity configuration to validate
 * @returns Validation errors if invalid
 */
function validateIdentity(identity: any): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!identity) {
    return errors;
  }

  if (!identity.type) {
    errors.push({
      path: 'identity.type',
      message: 'Identity type is required when identity is specified',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: `Specify an identity type. Valid values: ${VALID_IDENTITY_TYPES.join(', ')}`,
    });
  } else if (!VALID_IDENTITY_TYPES.includes(identity.type)) {
    errors.push({
      path: 'identity.type',
      message: `Invalid identity type: "${identity.type}". Must be one of: ${VALID_IDENTITY_TYPES.join(', ')}`,
      code: 'INVALID_ENUM_VALUE',
      fix: `Use one of: ${VALID_IDENTITY_TYPES.join(', ')}`,
    });
  }

  // Validate userAssignedIdentities if type includes UserAssigned
  if (identity.type && identity.type.includes('UserAssigned')) {
    if (!identity.userAssignedIdentities || Object.keys(identity.userAssignedIdentities).length === 0) {
      errors.push({
        path: 'identity.userAssignedIdentities',
        message: 'User-assigned identities must be specified when identity type includes UserAssigned',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Provide at least one user-assigned identity resource ID',
      });
    }
  }

  return errors;
}

/**
 * Validate Microsoft.OperationalInsights/workspaces resource.
 *
 * @param props - Resource properties to validate
 * @returns Validation result with any errors
 *
 * @example
 * ```typescript
 * const result = validateWorkspace({
 *   name: 'my-workspace',
 *   location: 'eastus',
 *   properties: {
 *     sku: { name: 'PerGB2018' },
 *     retentionInDays: 90
 *   }
 * });
 *
 * if (!result.valid) {
 *   console.error('Validation errors:', result.errors);
 * }
 * ```
 */
export function validateWorkspace(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required top-level properties
  if (!props.name) {
    errors.push({
      path: 'name',
      message: 'Workspace name is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide a workspace name',
    });
  } else {
    errors.push(...validateWorkspaceName(props.name));
  }

  if (!props.location) {
    errors.push({
      path: 'location',
      message: 'Location is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Specify an Azure region (e.g., "eastus", "westus2")',
    });
  }

  // Validate properties object
  if (!props.properties) {
    errors.push({
      path: 'properties',
      message: 'Properties object is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide a properties object with at least a SKU configuration',
    });
    return { valid: errors.length === 0, errors };
  }

  // Validate SKU
  errors.push(...validateWorkspaceSku(props.properties.sku));

  // Validate optional properties
  if (props.properties.workspaceCapping) {
    errors.push(...validateWorkspaceCapping(props.properties.workspaceCapping));
  }

  if (props.properties.retentionInDays !== undefined && props.properties.sku?.name) {
    errors.push(...validateRetention(props.properties.retentionInDays, props.properties.sku.name));
  }

  if (props.properties.publicNetworkAccessForIngestion !== undefined) {
    errors.push(
      ...validatePublicNetworkAccess(
        props.properties.publicNetworkAccessForIngestion,
        'properties.publicNetworkAccessForIngestion'
      )
    );
  }

  if (props.properties.publicNetworkAccessForQuery !== undefined) {
    errors.push(
      ...validatePublicNetworkAccess(props.properties.publicNetworkAccessForQuery, 'properties.publicNetworkAccessForQuery')
    );
  }

  // Validate identity if provided
  if (props.identity) {
    errors.push(...validateIdentity(props.identity));
  }

  // Validate forceCmkForQuery requires cluster
  if (props.properties.forceCmkForQuery && !props.properties.features?.clusterResourceId) {
    errors.push({
      path: 'properties.forceCmkForQuery',
      message: 'forceCmkForQuery requires the workspace to be linked to a dedicated cluster',
      code: 'INVALID_PROPERTY_COMBINATION',
      fix: 'Specify features.clusterResourceId or set forceCmkForQuery to false',
    });
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
