/**
 * Runtime validators for Microsoft.CognitiveServices (Azure Cognitive Services) resources.
 *
 * **API Version**: 2023-05-01
 * **Generated**: 2025-10-13
 *
 * @remarks
 * This file is auto-generated. Do not edit manually.
 * Generated by Felix (Schema & Validation Engineer)
 *
 * @packageDocumentation
 */

/**
 * Validation error.
 */
export interface ValidationError {
  readonly path: string;
  readonly message: string;
  readonly code: string;
  readonly fix?: string;
}

/**
 * Validation result.
 */
export interface ValidationResult {
  readonly valid: boolean;
  readonly errors: ValidationError[];
}

/**
 * Account name pattern for Microsoft.CognitiveServices/accounts.
 *
 * @remarks
 * Must start with alphanumeric, can contain alphanumeric, underscore, dot, hyphen.
 * Length: 2-64 characters.
 * Pattern: ^[a-zA-Z0-9][a-zA-Z0-9_.-]*$
 */
const ACCOUNT_NAME_PATTERN = /^[a-zA-Z0-9][a-zA-Z0-9_.-]*$/;

/**
 * Custom subdomain name pattern.
 *
 * @remarks
 * Must be lowercase letters, numbers, and hyphens only.
 * Cannot start or end with hyphen.
 * Length: 2-64 characters.
 */
const CUSTOM_SUBDOMAIN_PATTERN = /^[a-z0-9][a-z0-9-]*[a-z0-9]$/;

/**
 * Subnet ID pattern for Azure resource IDs.
 */
const SUBNET_ID_PATTERN =
  /^\/subscriptions\/[a-fA-F0-9-]{36}\/resourceGroups\/[\w.-]+\/providers\/Microsoft\.Network\/virtualNetworks\/[\w.-]+\/subnets\/[\w.-]+$/;

/**
 * Storage account resource ID pattern.
 */
const STORAGE_RESOURCE_ID_PATTERN =
  /^\/subscriptions\/[a-fA-F0-9-]{36}\/resourceGroups\/[\w.-]+\/providers\/Microsoft\.Storage\/storageAccounts\/[\w.-]+$/;

/**
 * Key Vault URI pattern.
 */
const KEY_VAULT_URI_PATTERN = /^https:\/\/[\w-]+\.vault\.azure\.net$/;

/**
 * Key Vault key identifier pattern.
 */
const KEY_VAULT_KEY_IDENTIFIER_PATTERN = /^https:\/\/[\w-]+\.vault\.azure\.net\/keys\/[\w-]+(\/[\w-]+)?$/;

/**
 * IP address or CIDR pattern.
 */
const IP_OR_CIDR_PATTERN =
  /^(\d{1,3}\.){3}\d{1,3}(\/\d{1,2})?$/;

/**
 * Azure GUID pattern.
 */
const GUID_PATTERN = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;

/**
 * Valid SKU tiers.
 */
const VALID_SKU_TIERS = ['Basic', 'Enterprise', 'Free', 'Premium', 'Standard'];

/**
 * Valid identity types.
 */
const VALID_IDENTITY_TYPES = ['None', 'SystemAssigned', 'SystemAssigned, UserAssigned', 'UserAssigned'];

/**
 * Valid public network access values.
 */
const VALID_PUBLIC_NETWORK_ACCESS = ['Disabled', 'Enabled'];

/**
 * Valid network ACL default actions.
 */
const VALID_NETWORK_ACL_DEFAULT_ACTIONS = ['Allow', 'Deny'];

/**
 * Valid encryption key sources.
 */
const VALID_ENCRYPTION_KEY_SOURCES = ['Microsoft.CognitiveServices', 'Microsoft.KeyVault'];

/**
 * Valid deployment scale types.
 */
const VALID_DEPLOYMENT_SCALE_TYPES = ['Manual', 'Standard'];

/**
 * Valid version upgrade options.
 */
const VALID_VERSION_UPGRADE_OPTIONS = [
  'NoAutoUpgrade',
  'OnceCurrentVersionExpired',
  'OnceNewDefaultVersionAvailable',
];

/**
 * Common Cognitive Services kinds.
 */
const COMMON_COGNITIVE_SERVICES_KINDS = [
  'OpenAI',
  'CognitiveServices',
  'ComputerVision',
  'Face',
  'TextAnalytics',
  'SpeechServices',
  'LUIS',
  'QnAMaker',
  'FormRecognizer',
  'AnomalyDetector',
  'ContentModerator',
  'CustomVision.Training',
  'CustomVision.Prediction',
  'PersonalizedRecommender',
  'TranslatorText',
];

/**
 * Validate Microsoft.CognitiveServices/accounts properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 *
 * @example
 * ```typescript
 * const result = validateCognitiveServicesAccount({
 *   name: 'myopenai-account',
 *   location: 'eastus',
 *   kind: 'OpenAI',
 *   sku: { name: 'S0' },
 *   properties: {
 *     customSubDomainName: 'myopenai'
 *   }
 * });
 *
 * if (!result.valid) {
 *   result.errors.forEach(err => console.error(err.message));
 * }
 * ```
 */
export function validateCognitiveServicesAccount(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required property: name
  if (props.name === undefined || props.name === null) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your Cognitive Services account definition',
    });
  } else {
    // Validate name type
    if (typeof props.name !== 'string') {
      errors.push({
        path: 'name',
        message: 'Property "name" must be a string',
        code: 'INVALID_TYPE',
        fix: 'Ensure "name" is a string value',
      });
    } else {
      // Validate name length
      if (props.name.length < 2 || props.name.length > 64) {
        errors.push({
          path: 'name',
          message: `Property "name" must be between 2 and 64 characters, got ${props.name.length}`,
          code: 'INVALID_LENGTH',
          fix: 'Use an account name between 2 and 64 characters. Example: "myopenai-account"',
        });
      }

      // Validate name pattern
      if (!ACCOUNT_NAME_PATTERN.test(props.name)) {
        errors.push({
          path: 'name',
          message: `Property "name" must match pattern ^[a-zA-Z0-9][a-zA-Z0-9_.-]*$. Got: "${props.name}"`,
          code: 'INVALID_PATTERN',
          fix: 'Account name must start with alphanumeric and can contain alphanumeric, underscore, dot, and hyphen characters.',
        });
      }
    }
  }

  // Validate required property: sku
  if (props.sku === undefined || props.sku === null) {
    errors.push({
      path: 'sku',
      message: 'Required property "sku" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "sku" property with at least a "name" field. Example: { name: "S0" }',
    });
  } else {
    // Validate sku.name (required)
    if (props.sku.name === undefined || props.sku.name === null) {
      errors.push({
        path: 'sku.name',
        message: 'Required property "sku.name" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add "sku.name". Common values: "F0" (free), "S0" (standard)',
      });
    } else if (typeof props.sku.name !== 'string') {
      errors.push({
        path: 'sku.name',
        message: 'Property "sku.name" must be a string',
        code: 'INVALID_TYPE',
        fix: 'Ensure "sku.name" is a string value',
      });
    }

    // Validate sku.tier if present
    if (props.sku.tier !== undefined) {
      if (!VALID_SKU_TIERS.includes(props.sku.tier)) {
        errors.push({
          path: 'sku.tier',
          message: `Property "sku.tier" must be one of: ${VALID_SKU_TIERS.join(', ')}. Got: "${props.sku.tier}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose a valid SKU tier: ${VALID_SKU_TIERS.join(', ')}`,
        });
      }
    }

    // Validate sku.capacity if present
    if (props.sku.capacity !== undefined) {
      if (typeof props.sku.capacity !== 'number') {
        errors.push({
          path: 'sku.capacity',
          message: 'Property "sku.capacity" must be a number',
          code: 'INVALID_TYPE',
          fix: 'Provide a numeric capacity value',
        });
      } else if (props.sku.capacity < 0) {
        errors.push({
          path: 'sku.capacity',
          message: `Property "sku.capacity" must be non-negative. Got: ${props.sku.capacity}`,
          code: 'INVALID_VALUE',
          fix: 'Provide a capacity value of 0 or greater',
        });
      }
    }
  }

  // Validate kind if present
  if (props.kind !== undefined) {
    if (typeof props.kind !== 'string') {
      errors.push({
        path: 'kind',
        message: 'Property "kind" must be a string',
        code: 'INVALID_TYPE',
        fix: 'Ensure "kind" is a string value',
      });
    } else if (!COMMON_COGNITIVE_SERVICES_KINDS.includes(props.kind)) {
      // This is a warning, not an error - custom kinds might exist
      errors.push({
        path: 'kind',
        message: `Property "kind" value "${props.kind}" is not a common Cognitive Services kind`,
        code: 'UNCOMMON_VALUE',
        fix: `Common kinds include: ${COMMON_COGNITIVE_SERVICES_KINDS.join(', ')}. Verify this is the correct kind for your use case.`,
      });
    }
  }

  // Validate location if present
  if (props.location !== undefined && typeof props.location !== 'string') {
    errors.push({
      path: 'location',
      message: 'Property "location" must be a string',
      code: 'INVALID_TYPE',
      fix: 'Provide a valid Azure region (e.g., "eastus", "westeurope")',
    });
  }

  // Validate identity if present
  if (props.identity !== undefined) {
    // Validate identity.type if present
    if (props.identity.type !== undefined) {
      if (!VALID_IDENTITY_TYPES.includes(props.identity.type)) {
        errors.push({
          path: 'identity.type',
          message: `Property "identity.type" must be one of: ${VALID_IDENTITY_TYPES.join(', ')}. Got: "${props.identity.type}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose a valid identity type: ${VALID_IDENTITY_TYPES.join(', ')}`,
        });
      }
    }

    // Validate identity.userAssignedIdentities if present
    if (props.identity.userAssignedIdentities !== undefined) {
      if (typeof props.identity.userAssignedIdentities !== 'object' || Array.isArray(props.identity.userAssignedIdentities)) {
        errors.push({
          path: 'identity.userAssignedIdentities',
          message: 'Property "identity.userAssignedIdentities" must be an object',
          code: 'INVALID_TYPE',
          fix: 'Provide an object with user-assigned identity resource IDs as keys',
        });
      }
    }
  }

  // Validate properties if present
  if (props.properties !== undefined) {
    const properties = props.properties;

    // Validate properties.customSubDomainName if present
    if (properties.customSubDomainName !== undefined) {
      if (typeof properties.customSubDomainName !== 'string') {
        errors.push({
          path: 'properties.customSubDomainName',
          message: 'Property "properties.customSubDomainName" must be a string',
          code: 'INVALID_TYPE',
          fix: 'Ensure "customSubDomainName" is a string value',
        });
      } else {
        // Validate length
        if (properties.customSubDomainName.length < 2 || properties.customSubDomainName.length > 64) {
          errors.push({
            path: 'properties.customSubDomainName',
            message: `Property "properties.customSubDomainName" must be between 2 and 64 characters, got ${properties.customSubDomainName.length}`,
            code: 'INVALID_LENGTH',
            fix: 'Use a custom subdomain name between 2 and 64 characters',
          });
        }

        // Validate pattern
        if (!CUSTOM_SUBDOMAIN_PATTERN.test(properties.customSubDomainName)) {
          errors.push({
            path: 'properties.customSubDomainName',
            message: `Property "properties.customSubDomainName" must be lowercase letters, numbers, and hyphens only, and cannot start or end with hyphen. Got: "${properties.customSubDomainName}"`,
            code: 'INVALID_PATTERN',
            fix: 'Use only lowercase letters, numbers, and hyphens. Example: "myopenai"',
          });
        }
      }
    }

    // Check if customSubDomainName is required
    if (props.kind === 'OpenAI' && !properties.customSubDomainName) {
      errors.push({
        path: 'properties.customSubDomainName',
        message: 'Property "properties.customSubDomainName" is required for OpenAI accounts',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add a custom subdomain name for your OpenAI account. Example: "myopenai"',
      });
    }

    // Validate properties.publicNetworkAccess if present
    if (properties.publicNetworkAccess !== undefined) {
      if (!VALID_PUBLIC_NETWORK_ACCESS.includes(properties.publicNetworkAccess)) {
        errors.push({
          path: 'properties.publicNetworkAccess',
          message: `Property "properties.publicNetworkAccess" must be one of: ${VALID_PUBLIC_NETWORK_ACCESS.join(', ')}. Got: "${properties.publicNetworkAccess}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose either "Enabled" or "Disabled"`,
        });
      }
    }

    // Validate properties.disableLocalAuth if present
    if (properties.disableLocalAuth !== undefined && typeof properties.disableLocalAuth !== 'boolean') {
      errors.push({
        path: 'properties.disableLocalAuth',
        message: 'Property "properties.disableLocalAuth" must be a boolean',
        code: 'INVALID_TYPE',
        fix: 'Set to true or false',
      });
    }

    // Validate properties.dynamicThrottlingEnabled if present
    if (properties.dynamicThrottlingEnabled !== undefined && typeof properties.dynamicThrottlingEnabled !== 'boolean') {
      errors.push({
        path: 'properties.dynamicThrottlingEnabled',
        message: 'Property "properties.dynamicThrottlingEnabled" must be a boolean',
        code: 'INVALID_TYPE',
        fix: 'Set to true or false',
      });
    }

    // Validate properties.restrictOutboundNetworkAccess if present
    if (properties.restrictOutboundNetworkAccess !== undefined && typeof properties.restrictOutboundNetworkAccess !== 'boolean') {
      errors.push({
        path: 'properties.restrictOutboundNetworkAccess',
        message: 'Property "properties.restrictOutboundNetworkAccess" must be a boolean',
        code: 'INVALID_TYPE',
        fix: 'Set to true or false',
      });
    }

    // Validate properties.allowedFqdnList if present
    if (properties.allowedFqdnList !== undefined) {
      if (!Array.isArray(properties.allowedFqdnList)) {
        errors.push({
          path: 'properties.allowedFqdnList',
          message: 'Property "properties.allowedFqdnList" must be an array',
          code: 'INVALID_TYPE',
          fix: 'Provide an array of FQDN strings',
        });
      } else {
        properties.allowedFqdnList.forEach((fqdn: any, index: number) => {
          if (typeof fqdn !== 'string') {
            errors.push({
              path: `properties.allowedFqdnList[${index}]`,
              message: `FQDN at index ${index} must be a string`,
              code: 'INVALID_TYPE',
              fix: 'Provide a valid FQDN string',
            });
          }
        });
      }
    }

    // Validate properties.networkAcls if present
    if (properties.networkAcls !== undefined) {
      const networkAcls = properties.networkAcls;

      // Validate defaultAction if present
      if (networkAcls.defaultAction !== undefined) {
        if (!VALID_NETWORK_ACL_DEFAULT_ACTIONS.includes(networkAcls.defaultAction)) {
          errors.push({
            path: 'properties.networkAcls.defaultAction',
            message: `Property "properties.networkAcls.defaultAction" must be one of: ${VALID_NETWORK_ACL_DEFAULT_ACTIONS.join(', ')}. Got: "${networkAcls.defaultAction}"`,
            code: 'INVALID_ENUM_VALUE',
            fix: `Choose either "Allow" or "Deny"`,
          });
        }
      }

      // Validate ipRules if present
      if (networkAcls.ipRules !== undefined) {
        if (!Array.isArray(networkAcls.ipRules)) {
          errors.push({
            path: 'properties.networkAcls.ipRules',
            message: 'Property "properties.networkAcls.ipRules" must be an array',
            code: 'INVALID_TYPE',
            fix: 'Provide an array of IP rule objects',
          });
        } else {
          networkAcls.ipRules.forEach((rule: any, index: number) => {
            if (!rule.value) {
              errors.push({
                path: `properties.networkAcls.ipRules[${index}].value`,
                message: 'IP rule must have a "value" property',
                code: 'REQUIRED_PROPERTY_MISSING',
                fix: 'Provide an IP address or CIDR range (e.g., "192.168.1.0/24")',
              });
            } else if (typeof rule.value !== 'string') {
              errors.push({
                path: `properties.networkAcls.ipRules[${index}].value`,
                message: 'IP rule value must be a string',
                code: 'INVALID_TYPE',
                fix: 'Provide a string IP address or CIDR range',
              });
            } else if (!IP_OR_CIDR_PATTERN.test(rule.value)) {
              errors.push({
                path: `properties.networkAcls.ipRules[${index}].value`,
                message: `Invalid IP address or CIDR format: "${rule.value}"`,
                code: 'INVALID_PATTERN',
                fix: 'Use IPv4 address (e.g., "192.168.1.1") or CIDR notation (e.g., "192.168.1.0/24")',
              });
            }
          });
        }
      }

      // Validate virtualNetworkRules if present
      if (networkAcls.virtualNetworkRules !== undefined) {
        if (!Array.isArray(networkAcls.virtualNetworkRules)) {
          errors.push({
            path: 'properties.networkAcls.virtualNetworkRules',
            message: 'Property "properties.networkAcls.virtualNetworkRules" must be an array',
            code: 'INVALID_TYPE',
            fix: 'Provide an array of virtual network rule objects',
          });
        } else {
          networkAcls.virtualNetworkRules.forEach((rule: any, index: number) => {
            if (!rule.id) {
              errors.push({
                path: `properties.networkAcls.virtualNetworkRules[${index}].id`,
                message: 'Virtual network rule must have an "id" property',
                code: 'REQUIRED_PROPERTY_MISSING',
                fix: 'Provide a subnet resource ID',
              });
            } else if (typeof rule.id !== 'string') {
              errors.push({
                path: `properties.networkAcls.virtualNetworkRules[${index}].id`,
                message: 'Virtual network rule ID must be a string',
                code: 'INVALID_TYPE',
                fix: 'Provide a valid subnet resource ID',
              });
            } else if (!SUBNET_ID_PATTERN.test(rule.id)) {
              errors.push({
                path: `properties.networkAcls.virtualNetworkRules[${index}].id`,
                message: `Invalid subnet resource ID: "${rule.id}"`,
                code: 'INVALID_PATTERN',
                fix: 'Use format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}',
              });
            }

            if (rule.ignoreMissingVnetServiceEndpoint !== undefined && typeof rule.ignoreMissingVnetServiceEndpoint !== 'boolean') {
              errors.push({
                path: `properties.networkAcls.virtualNetworkRules[${index}].ignoreMissingVnetServiceEndpoint`,
                message: 'Property "ignoreMissingVnetServiceEndpoint" must be a boolean',
                code: 'INVALID_TYPE',
                fix: 'Set to true or false',
              });
            }
          });
        }
      }
    }

    // Validate properties.encryption if present
    if (properties.encryption !== undefined) {
      const encryption = properties.encryption;

      // Validate keySource if present
      if (encryption.keySource !== undefined) {
        if (!VALID_ENCRYPTION_KEY_SOURCES.includes(encryption.keySource)) {
          errors.push({
            path: 'properties.encryption.keySource',
            message: `Property "properties.encryption.keySource" must be one of: ${VALID_ENCRYPTION_KEY_SOURCES.join(', ')}. Got: "${encryption.keySource}"`,
            code: 'INVALID_ENUM_VALUE',
            fix: `Choose either "Microsoft.CognitiveServices" or "Microsoft.KeyVault"`,
          });
        }

        // If KeyVault, validate keyVaultProperties
        if (encryption.keySource === 'Microsoft.KeyVault') {
          if (!encryption.keyVaultProperties) {
            errors.push({
              path: 'properties.encryption.keyVaultProperties',
              message: 'Property "properties.encryption.keyVaultProperties" is required when keySource is "Microsoft.KeyVault"',
              code: 'REQUIRED_PROPERTY_MISSING',
              fix: 'Add keyVaultProperties with keyIdentifier or keyVaultUri, keyName, and keyVersion',
            });
          } else {
            const kvProps = encryption.keyVaultProperties;

            // Validate keyIdentifier if present
            if (kvProps.keyIdentifier !== undefined) {
              if (typeof kvProps.keyIdentifier !== 'string') {
                errors.push({
                  path: 'properties.encryption.keyVaultProperties.keyIdentifier',
                  message: 'Property "keyIdentifier" must be a string',
                  code: 'INVALID_TYPE',
                  fix: 'Provide a valid Key Vault key URI',
                });
              } else if (!KEY_VAULT_KEY_IDENTIFIER_PATTERN.test(kvProps.keyIdentifier)) {
                errors.push({
                  path: 'properties.encryption.keyVaultProperties.keyIdentifier',
                  message: `Invalid Key Vault key identifier: "${kvProps.keyIdentifier}"`,
                  code: 'INVALID_PATTERN',
                  fix: 'Use format: https://{vault}.vault.azure.net/keys/{key}/{version}',
                });
              }
            }

            // Validate keyVaultUri if present
            if (kvProps.keyVaultUri !== undefined) {
              if (typeof kvProps.keyVaultUri !== 'string') {
                errors.push({
                  path: 'properties.encryption.keyVaultProperties.keyVaultUri',
                  message: 'Property "keyVaultUri" must be a string',
                  code: 'INVALID_TYPE',
                  fix: 'Provide a valid Key Vault URI',
                });
              } else if (!KEY_VAULT_URI_PATTERN.test(kvProps.keyVaultUri)) {
                errors.push({
                  path: 'properties.encryption.keyVaultProperties.keyVaultUri',
                  message: `Invalid Key Vault URI: "${kvProps.keyVaultUri}"`,
                  code: 'INVALID_PATTERN',
                  fix: 'Use format: https://{vault}.vault.azure.net',
                });
              }
            }

            // Validate identityClientId if present
            if (kvProps.identityClientId !== undefined) {
              if (typeof kvProps.identityClientId !== 'string') {
                errors.push({
                  path: 'properties.encryption.keyVaultProperties.identityClientId',
                  message: 'Property "identityClientId" must be a string',
                  code: 'INVALID_TYPE',
                  fix: 'Provide a valid client ID (GUID)',
                });
              } else if (!GUID_PATTERN.test(kvProps.identityClientId)) {
                errors.push({
                  path: 'properties.encryption.keyVaultProperties.identityClientId',
                  message: `Invalid GUID format for identityClientId: "${kvProps.identityClientId}"`,
                  code: 'INVALID_PATTERN',
                  fix: 'Provide a valid GUID (e.g., "12345678-1234-1234-1234-123456789012")',
                });
              }
            }
          }
        }
      }
    }

    // Validate properties.userOwnedStorage if present
    if (properties.userOwnedStorage !== undefined) {
      if (!Array.isArray(properties.userOwnedStorage)) {
        errors.push({
          path: 'properties.userOwnedStorage',
          message: 'Property "properties.userOwnedStorage" must be an array',
          code: 'INVALID_TYPE',
          fix: 'Provide an array of user-owned storage configurations',
        });
      } else {
        properties.userOwnedStorage.forEach((storage: any, index: number) => {
          if (storage.resourceId !== undefined) {
            if (typeof storage.resourceId !== 'string') {
              errors.push({
                path: `properties.userOwnedStorage[${index}].resourceId`,
                message: 'Storage resourceId must be a string',
                code: 'INVALID_TYPE',
                fix: 'Provide a valid storage account resource ID',
              });
            } else if (!STORAGE_RESOURCE_ID_PATTERN.test(storage.resourceId)) {
              errors.push({
                path: `properties.userOwnedStorage[${index}].resourceId`,
                message: `Invalid storage account resource ID: "${storage.resourceId}"`,
                code: 'INVALID_PATTERN',
                fix: 'Use format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{storageAccountName}',
              });
            }
          }

          if (storage.identityClientId !== undefined) {
            if (typeof storage.identityClientId !== 'string') {
              errors.push({
                path: `properties.userOwnedStorage[${index}].identityClientId`,
                message: 'Storage identityClientId must be a string',
                code: 'INVALID_TYPE',
                fix: 'Provide a valid client ID (GUID)',
              });
            } else if (!GUID_PATTERN.test(storage.identityClientId)) {
              errors.push({
                path: `properties.userOwnedStorage[${index}].identityClientId`,
                message: `Invalid GUID format for identityClientId: "${storage.identityClientId}"`,
                code: 'INVALID_PATTERN',
                fix: 'Provide a valid GUID',
              });
            }
          }
        });
      }
    }
  }

  // Validate tags if present
  if (props.tags !== undefined) {
    if (typeof props.tags !== 'object' || Array.isArray(props.tags)) {
      errors.push({
        path: 'tags',
        message: 'Property "tags" must be an object with string key-value pairs',
        code: 'INVALID_TYPE',
        fix: 'Provide an object with string keys and values, e.g., { environment: "production" }',
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate Microsoft.CognitiveServices/accounts/deployments properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 *
 * @example
 * ```typescript
 * const result = validateCognitiveServicesDeployment({
 *   name: 'gpt4-deployment',
 *   properties: {
 *     model: {
 *       format: 'OpenAI',
 *       name: 'gpt-4',
 *       version: '0613'
 *     },
 *     scaleSettings: {
 *       scaleType: 'Standard',
 *       capacity: 30
 *     }
 *   }
 * });
 * ```
 */
export function validateCognitiveServicesDeployment(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required property: name
  if (props.name === undefined || props.name === null) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your deployment definition',
    });
  } else if (typeof props.name !== 'string') {
    errors.push({
      path: 'name',
      message: 'Property "name" must be a string',
      code: 'INVALID_TYPE',
      fix: 'Ensure "name" is a string value (e.g., "gpt4-deployment")',
    });
  }

  // Validate properties if present
  if (props.properties !== undefined) {
    const properties = props.properties;

    // Validate properties.model if present
    if (properties.model !== undefined) {
      const model = properties.model;

      // Validate model.name if present
      if (model.name !== undefined && typeof model.name !== 'string') {
        errors.push({
          path: 'properties.model.name',
          message: 'Property "properties.model.name" must be a string',
          code: 'INVALID_TYPE',
          fix: 'Provide a valid model name (e.g., "gpt-4", "gpt-35-turbo")',
        });
      }

      // Validate model.version if present
      if (model.version !== undefined && typeof model.version !== 'string') {
        errors.push({
          path: 'properties.model.version',
          message: 'Property "properties.model.version" must be a string',
          code: 'INVALID_TYPE',
          fix: 'Provide a valid model version (e.g., "0613")',
        });
      }

      // Validate model.format if present
      if (model.format !== undefined && typeof model.format !== 'string') {
        errors.push({
          path: 'properties.model.format',
          message: 'Property "properties.model.format" must be a string',
          code: 'INVALID_TYPE',
          fix: 'Provide a valid model format (e.g., "OpenAI")',
        });
      }

      // Validate model.source if present
      if (model.source !== undefined && typeof model.source !== 'string') {
        errors.push({
          path: 'properties.model.source',
          message: 'Property "properties.model.source" must be a string',
          code: 'INVALID_TYPE',
          fix: 'Provide a valid model source',
        });
      }
    }

    // Validate properties.scaleSettings if present
    if (properties.scaleSettings !== undefined) {
      const scaleSettings = properties.scaleSettings;

      // Validate scaleType if present
      if (scaleSettings.scaleType !== undefined) {
        if (!VALID_DEPLOYMENT_SCALE_TYPES.includes(scaleSettings.scaleType)) {
          errors.push({
            path: 'properties.scaleSettings.scaleType',
            message: `Property "properties.scaleSettings.scaleType" must be one of: ${VALID_DEPLOYMENT_SCALE_TYPES.join(', ')}. Got: "${scaleSettings.scaleType}"`,
            code: 'INVALID_ENUM_VALUE',
            fix: `Choose either "Manual" or "Standard"`,
          });
        }
      }

      // Validate capacity if present
      if (scaleSettings.capacity !== undefined) {
        if (typeof scaleSettings.capacity !== 'number') {
          errors.push({
            path: 'properties.scaleSettings.capacity',
            message: 'Property "properties.scaleSettings.capacity" must be a number',
            code: 'INVALID_TYPE',
            fix: 'Provide a numeric capacity value (e.g., 30 for 30K TPM)',
          });
        } else if (scaleSettings.capacity < 0) {
          errors.push({
            path: 'properties.scaleSettings.capacity',
            message: `Property "properties.scaleSettings.capacity" must be non-negative. Got: ${scaleSettings.capacity}`,
            code: 'INVALID_VALUE',
            fix: 'Provide a capacity value of 0 or greater',
          });
        } else if (scaleSettings.capacity > 0 && scaleSettings.capacity < 10) {
          // Warning: very low capacity
          errors.push({
            path: 'properties.scaleSettings.capacity',
            message: `Deployment capacity is ${scaleSettings.capacity}K TPM, which may be too low for production use`,
            code: 'LOW_CAPACITY_WARNING',
            fix: 'Consider using at least 10K TPM for production workloads',
          });
        }
      }
    }

    // Validate properties.versionUpgradeOption if present
    if (properties.versionUpgradeOption !== undefined) {
      if (!VALID_VERSION_UPGRADE_OPTIONS.includes(properties.versionUpgradeOption)) {
        errors.push({
          path: 'properties.versionUpgradeOption',
          message: `Property "properties.versionUpgradeOption" must be one of: ${VALID_VERSION_UPGRADE_OPTIONS.join(', ')}. Got: "${properties.versionUpgradeOption}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose a valid version upgrade option: ${VALID_VERSION_UPGRADE_OPTIONS.join(', ')}`,
        });
      }
    }

    // Validate properties.raiPolicyName if present
    if (properties.raiPolicyName !== undefined && typeof properties.raiPolicyName !== 'string') {
      errors.push({
        path: 'properties.raiPolicyName',
        message: 'Property "properties.raiPolicyName" must be a string',
        code: 'INVALID_TYPE',
        fix: 'Provide a valid RAI policy name',
      });
    }
  }

  // Validate sku if present
  if (props.sku !== undefined) {
    // Validate sku.name if present
    if (props.sku.name !== undefined && typeof props.sku.name !== 'string') {
      errors.push({
        path: 'sku.name',
        message: 'Property "sku.name" must be a string',
        code: 'INVALID_TYPE',
        fix: 'Provide a valid SKU name',
      });
    }

    // Validate sku.tier if present
    if (props.sku.tier !== undefined) {
      if (!VALID_SKU_TIERS.includes(props.sku.tier)) {
        errors.push({
          path: 'sku.tier',
          message: `Property "sku.tier" must be one of: ${VALID_SKU_TIERS.join(', ')}. Got: "${props.sku.tier}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose a valid SKU tier: ${VALID_SKU_TIERS.join(', ')}`,
        });
      }
    }

    // Validate sku.capacity if present
    if (props.sku.capacity !== undefined) {
      if (typeof props.sku.capacity !== 'number') {
        errors.push({
          path: 'sku.capacity',
          message: 'Property "sku.capacity" must be a number',
          code: 'INVALID_TYPE',
          fix: 'Provide a numeric capacity value',
        });
      } else if (props.sku.capacity < 0) {
        errors.push({
          path: 'sku.capacity',
          message: `Property "sku.capacity" must be non-negative. Got: ${props.sku.capacity}`,
          code: 'INVALID_VALUE',
          fix: 'Provide a capacity value of 0 or greater',
        });
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
