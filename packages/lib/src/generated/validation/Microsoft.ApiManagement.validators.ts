/**
 * Runtime validators for Microsoft.ApiManagement resources.
 *
 * **API Version**: 2024-10-01-preview
 * **Generated**: 2025-10-13
 *
 * @remarks
 * This file is auto-generated. Do not edit manually.
 * Generated by Felix (Schema & Validation Engineer)
 *
 * @packageDocumentation
 */

/**
 * Validation error.
 */
export interface ValidationError {
  readonly path: string;
  readonly message: string;
  readonly code: string;
  readonly fix?: string;
}

/**
 * Validation result.
 */
export interface ValidationResult {
  readonly valid: boolean;
  readonly errors: ValidationError[];
}

/**
 * Service name pattern for Microsoft.ApiManagement/service.
 *
 * @remarks
 * Must start with a letter, contain only letters, numbers, and hyphens, and end with a letter or number.
 * Length: 1-50 characters.
 */
const SERVICE_NAME_PATTERN = /^[a-zA-Z](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?$/;

/**
 * API identifier pattern.
 * Cannot contain: * # & + : < > ?
 */
const API_ID_PATTERN = /^[^*#&+:<>?]+$/;

/**
 * Email address pattern.
 */
const EMAIL_PATTERN = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

/**
 * Azure subnet resource ID pattern.
 */
const SUBNET_ID_PATTERN =
  /^\/subscriptions\/[a-fA-F0-9-]{36}\/resourceGroups\/[\w.-]+\/providers\/Microsoft\.Network\/virtualNetworks\/[\w.-]+\/subnets\/[\w.-]+$/;

/**
 * Azure public IP address resource ID pattern.
 */
const PUBLIC_IP_PATTERN =
  /^\/subscriptions\/[a-fA-F0-9-]{36}\/resourceGroups\/[\w.-]+\/providers\/Microsoft\.Network\/publicIPAddresses\/[\w.-]+$/;

/**
 * Key Vault secret identifier pattern.
 */
const KEY_VAULT_ID_PATTERN =
  /^https:\/\/[\w-]+\.vault\.azure\.net\/secrets\/[\w-]+(\/[a-fA-F0-9]{32})?$/;

/**
 * Hostname pattern (FQDN).
 */
const HOSTNAME_PATTERN = /^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/;

/**
 * Validate Microsoft.ApiManagement/service properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 *
 * @example
 * ```typescript
 * const result = validateApiManagementService({
 *   name: 'contoso-api',
 *   location: 'westus2',
 *   sku: {
 *     name: 'Developer',
 *     capacity: 1
 *   },
 *   properties: {
 *     publisherEmail: 'admin@contoso.com',
 *     publisherName: 'Contoso Inc.'
 *   }
 * });
 *
 * if (!result.valid) {
 *   result.errors.forEach(err => console.error(err.message));
 * }
 * ```
 */
export function validateApiManagementService(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required property: name
  if (props.name === undefined || props.name === null) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your API Management service definition',
    });
  } else {
    if (typeof props.name !== 'string') {
      errors.push({
        path: 'name',
        message: 'Property "name" must be a string',
        code: 'INVALID_TYPE',
        fix: 'Ensure "name" is a string value',
      });
    } else {
      // Validate name length
      if (props.name.length < 1 || props.name.length > 50) {
        errors.push({
          path: 'name',
          message: `Property "name" must be between 1 and 50 characters, got ${props.name.length}`,
          code: 'INVALID_LENGTH',
          fix: 'Use a service name between 1 and 50 characters. Example: "contoso-api"',
        });
      }

      // Validate name pattern
      if (!SERVICE_NAME_PATTERN.test(props.name)) {
        errors.push({
          path: 'name',
          message: `Property "name" must start with a letter and contain only letters, numbers, and hyphens. Got: "${props.name}"`,
          code: 'INVALID_PATTERN',
          fix: 'Use a valid service name format (e.g., "contoso-api", "my-api-service"). Must start with a letter and end with alphanumeric character.',
        });
      }
    }
  }

  // Validate required property: location
  if (props.location === undefined || props.location === null) {
    errors.push({
      path: 'location',
      message: 'Required property "location" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "location" property with a valid Azure region (e.g., "westus2", "eastus")',
    });
  } else if (typeof props.location !== 'string') {
    errors.push({
      path: 'location',
      message: 'Property "location" must be a string',
      code: 'INVALID_TYPE',
      fix: 'Provide a valid Azure region string',
    });
  }

  // Validate required property: sku
  if (props.sku === undefined || props.sku === null) {
    errors.push({
      path: 'sku',
      message: 'Required property "sku" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "sku" property with name and capacity',
    });
  } else {
    // Validate sku.name
    if (props.sku.name === undefined || props.sku.name === null) {
      errors.push({
        path: 'sku.name',
        message: 'Required property "sku.name" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add the "sku.name" property',
      });
    } else {
      const validSkus = [
        'Developer',
        'Basic',
        'BasicV2',
        'Standard',
        'StandardV2',
        'Premium',
        'Consumption',
        'Isolated',
      ];
      if (!validSkus.includes(props.sku.name)) {
        errors.push({
          path: 'sku.name',
          message: `Property "sku.name" must be one of: ${validSkus.join(', ')}. Got: "${props.sku.name}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose a valid SKU: ${validSkus.join(', ')}`,
        });
      }
    }

    // Validate sku.capacity if present
    if (props.sku.capacity !== undefined) {
      if (typeof props.sku.capacity !== 'number' || !Number.isInteger(props.sku.capacity)) {
        errors.push({
          path: 'sku.capacity',
          message: 'Property "sku.capacity" must be an integer',
          code: 'INVALID_TYPE',
          fix: 'Provide an integer value for capacity',
        });
      } else if (props.sku.capacity < 0) {
        errors.push({
          path: 'sku.capacity',
          message: 'Property "sku.capacity" must be 0 or greater',
          code: 'VALUE_OUT_OF_RANGE',
          fix: 'Use a non-negative integer for capacity',
        });
      } else {
        // Validate capacity based on SKU
        const skuName = props.sku.name;
        if ((skuName === 'Developer' || skuName === 'Consumption') && props.sku.capacity !== 0) {
          errors.push({
            path: 'sku.capacity',
            message: `Property "sku.capacity" must be 0 for ${skuName} SKU, got ${props.sku.capacity}`,
            code: 'INVALID_VALUE',
            fix: `Set capacity to 0 for ${skuName} SKU`,
          });
        } else if (skuName === 'Basic' && props.sku.capacity > 2) {
          errors.push({
            path: 'sku.capacity',
            message: `Property "sku.capacity" must be 1-2 for Basic SKU, got ${props.sku.capacity}`,
            code: 'VALUE_OUT_OF_RANGE',
            fix: 'Set capacity to 1 or 2 for Basic SKU',
          });
        } else if (skuName === 'Standard' && props.sku.capacity > 4) {
          errors.push({
            path: 'sku.capacity',
            message: `Property "sku.capacity" must be 1-4 for Standard SKU, got ${props.sku.capacity}`,
            code: 'VALUE_OUT_OF_RANGE',
            fix: 'Set capacity to 1-4 for Standard SKU',
          });
        } else if (skuName === 'Premium' && props.sku.capacity > 10) {
          errors.push({
            path: 'sku.capacity',
            message: `Property "sku.capacity" must be 1-10 for Premium SKU, got ${props.sku.capacity}`,
            code: 'VALUE_OUT_OF_RANGE',
            fix: 'Set capacity to 1-10 for Premium SKU',
          });
        }
      }
    }
  }

  // Validate required property: properties
  if (props.properties === undefined || props.properties === null) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with service configuration',
    });
  } else {
    // Validate required property: publisherEmail
    if (props.properties.publisherEmail === undefined || props.properties.publisherEmail === null) {
      errors.push({
        path: 'properties.publisherEmail',
        message: 'Required property "properties.publisherEmail" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add the "publisherEmail" property with a valid email address',
      });
    } else {
      if (typeof props.properties.publisherEmail !== 'string') {
        errors.push({
          path: 'properties.publisherEmail',
          message: 'Property "properties.publisherEmail" must be a string',
          code: 'INVALID_TYPE',
          fix: 'Provide a valid email address string',
        });
      } else {
        // Validate email format
        if (!EMAIL_PATTERN.test(props.properties.publisherEmail)) {
          errors.push({
            path: 'properties.publisherEmail',
            message: `Property "properties.publisherEmail" must be a valid email address. Got: "${props.properties.publisherEmail}"`,
            code: 'INVALID_PATTERN',
            fix: 'Use a valid email format (e.g., "admin@contoso.com")',
          });
        }

        // Validate email length
        if (props.properties.publisherEmail.length > 100) {
          errors.push({
            path: 'properties.publisherEmail',
            message: `Property "properties.publisherEmail" must not exceed 100 characters, got ${props.properties.publisherEmail.length}`,
            code: 'INVALID_LENGTH',
            fix: 'Use an email address with 100 characters or fewer',
          });
        }
      }
    }

    // Validate required property: publisherName
    if (props.properties.publisherName === undefined || props.properties.publisherName === null) {
      errors.push({
        path: 'properties.publisherName',
        message: 'Required property "properties.publisherName" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add the "publisherName" property with the organization name',
      });
    } else {
      if (typeof props.properties.publisherName !== 'string') {
        errors.push({
          path: 'properties.publisherName',
          message: 'Property "properties.publisherName" must be a string',
          code: 'INVALID_TYPE',
          fix: 'Provide a valid publisher name string',
        });
      } else {
        // Validate publisher name length
        if (props.properties.publisherName.length > 100) {
          errors.push({
            path: 'properties.publisherName',
            message: `Property "properties.publisherName" must not exceed 100 characters, got ${props.properties.publisherName.length}`,
            code: 'INVALID_LENGTH',
            fix: 'Use a publisher name with 100 characters or fewer',
          });
        }
      }
    }

    // Validate virtualNetworkType if present
    if (props.properties.virtualNetworkType !== undefined) {
      const validTypes = ['None', 'External', 'Internal'];
      if (!validTypes.includes(props.properties.virtualNetworkType)) {
        errors.push({
          path: 'properties.virtualNetworkType',
          message: `Property "properties.virtualNetworkType" must be one of: ${validTypes.join(', ')}. Got: "${props.properties.virtualNetworkType}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose a valid virtual network type: ${validTypes.join(', ')}`,
        });
      }
    }

    // Validate publicNetworkAccess if present
    if (props.properties.publicNetworkAccess !== undefined) {
      const validValues = ['Enabled', 'Disabled'];
      if (!validValues.includes(props.properties.publicNetworkAccess)) {
        errors.push({
          path: 'properties.publicNetworkAccess',
          message: `Property "properties.publicNetworkAccess" must be one of: ${validValues.join(', ')}. Got: "${props.properties.publicNetworkAccess}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: 'Choose either "Enabled" or "Disabled"',
        });
      }
    }

    // Validate virtualNetworkConfiguration if present
    if (props.properties.virtualNetworkConfiguration !== undefined) {
      const vnetConfig = props.properties.virtualNetworkConfiguration;

      if (vnetConfig.subnetResourceId !== undefined) {
        if (typeof vnetConfig.subnetResourceId !== 'string') {
          errors.push({
            path: 'properties.virtualNetworkConfiguration.subnetResourceId',
            message: 'Property "properties.virtualNetworkConfiguration.subnetResourceId" must be a string',
            code: 'INVALID_TYPE',
            fix: 'Provide a valid Azure subnet resource ID',
          });
        } else if (!SUBNET_ID_PATTERN.test(vnetConfig.subnetResourceId)) {
          errors.push({
            path: 'properties.virtualNetworkConfiguration.subnetResourceId',
            message: 'Property "properties.virtualNetworkConfiguration.subnetResourceId" must be a valid Azure subnet resource ID',
            code: 'INVALID_PATTERN',
            fix: 'Use format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}',
          });
        }
      }
    }

    // Validate publicIpAddressId if present
    if (props.properties.publicIpAddressId !== undefined) {
      if (typeof props.properties.publicIpAddressId !== 'string') {
        errors.push({
          path: 'properties.publicIpAddressId',
          message: 'Property "properties.publicIpAddressId" must be a string',
          code: 'INVALID_TYPE',
          fix: 'Provide a valid Azure public IP address resource ID',
        });
      } else if (!PUBLIC_IP_PATTERN.test(props.properties.publicIpAddressId)) {
        errors.push({
          path: 'properties.publicIpAddressId',
          message: 'Property "properties.publicIpAddressId" must be a valid Azure public IP address resource ID',
          code: 'INVALID_PATTERN',
          fix: 'Use format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPAddresses/{ipName}',
        });
      }
    }

    // Validate hostnameConfigurations if present
    if (props.properties.hostnameConfigurations !== undefined) {
      if (!Array.isArray(props.properties.hostnameConfigurations)) {
        errors.push({
          path: 'properties.hostnameConfigurations',
          message: 'Property "properties.hostnameConfigurations" must be an array',
          code: 'INVALID_TYPE',
          fix: 'Provide an array of hostname configuration objects',
        });
      } else {
        props.properties.hostnameConfigurations.forEach((config: any, index: number) => {
          const basePath = `properties.hostnameConfigurations[${index}]`;

          // Validate type (required)
          if (config.type === undefined) {
            errors.push({
              path: `${basePath}.type`,
              message: `Required property "${basePath}.type" is missing`,
              code: 'REQUIRED_PROPERTY_MISSING',
              fix: 'Add the "type" property (Proxy, Portal, Management, Scm, or DeveloperPortal)',
            });
          } else {
            const validTypes = ['Proxy', 'Portal', 'Management', 'Scm', 'DeveloperPortal'];
            if (!validTypes.includes(config.type)) {
              errors.push({
                path: `${basePath}.type`,
                message: `Property "${basePath}.type" must be one of: ${validTypes.join(', ')}. Got: "${config.type}"`,
                code: 'INVALID_ENUM_VALUE',
                fix: `Choose a valid hostname type: ${validTypes.join(', ')}`,
              });
            }
          }

          // Validate hostName (required)
          if (config.hostName === undefined) {
            errors.push({
              path: `${basePath}.hostName`,
              message: `Required property "${basePath}.hostName" is missing`,
              code: 'REQUIRED_PROPERTY_MISSING',
              fix: 'Add the "hostName" property with a fully qualified domain name',
            });
          } else if (typeof config.hostName !== 'string') {
            errors.push({
              path: `${basePath}.hostName`,
              message: `Property "${basePath}.hostName" must be a string`,
              code: 'INVALID_TYPE',
              fix: 'Provide a valid hostname string',
            });
          } else if (!HOSTNAME_PATTERN.test(config.hostName)) {
            errors.push({
              path: `${basePath}.hostName`,
              message: `Property "${basePath}.hostName" must be a valid hostname. Got: "${config.hostName}"`,
              code: 'INVALID_PATTERN',
              fix: 'Use a valid FQDN format (e.g., "api.contoso.com")',
            });
          }

          // Validate keyVaultId if present
          if (config.keyVaultId !== undefined) {
            if (typeof config.keyVaultId !== 'string') {
              errors.push({
                path: `${basePath}.keyVaultId`,
                message: `Property "${basePath}.keyVaultId" must be a string`,
                code: 'INVALID_TYPE',
                fix: 'Provide a valid Key Vault secret identifier',
              });
            } else if (!KEY_VAULT_ID_PATTERN.test(config.keyVaultId)) {
              errors.push({
                path: `${basePath}.keyVaultId`,
                message: `Property "${basePath}.keyVaultId" must be a valid Key Vault secret identifier`,
                code: 'INVALID_PATTERN',
                fix: 'Use format: https://{vaultName}.vault.azure.net/secrets/{secretName}',
              });
            }
          }

          // Validate certificateSource if present
          if (config.certificateSource !== undefined) {
            const validSources = ['Managed', 'KeyVault', 'Custom', 'BuiltIn'];
            if (!validSources.includes(config.certificateSource)) {
              errors.push({
                path: `${basePath}.certificateSource`,
                message: `Property "${basePath}.certificateSource" must be one of: ${validSources.join(', ')}. Got: "${config.certificateSource}"`,
                code: 'INVALID_ENUM_VALUE',
                fix: `Choose a valid certificate source: ${validSources.join(', ')}`,
              });
            }
          }
        });
      }
    }

    // Validate additionalLocations if present
    if (props.properties.additionalLocations !== undefined) {
      if (!Array.isArray(props.properties.additionalLocations)) {
        errors.push({
          path: 'properties.additionalLocations',
          message: 'Property "properties.additionalLocations" must be an array',
          code: 'INVALID_TYPE',
          fix: 'Provide an array of additional location objects',
        });
      } else {
        props.properties.additionalLocations.forEach((location: any, index: number) => {
          const basePath = `properties.additionalLocations[${index}]`;

          // Validate location (required)
          if (location.location === undefined) {
            errors.push({
              path: `${basePath}.location`,
              message: `Required property "${basePath}.location" is missing`,
              code: 'REQUIRED_PROPERTY_MISSING',
              fix: 'Add the "location" property with a valid Azure region',
            });
          } else if (typeof location.location !== 'string') {
            errors.push({
              path: `${basePath}.location`,
              message: `Property "${basePath}.location" must be a string`,
              code: 'INVALID_TYPE',
              fix: 'Provide a valid Azure region string',
            });
          }

          // Validate sku (required)
          if (location.sku === undefined) {
            errors.push({
              path: `${basePath}.sku`,
              message: `Required property "${basePath}.sku" is missing`,
              code: 'REQUIRED_PROPERTY_MISSING',
              fix: 'Add the "sku" property with name and capacity',
            });
          }
        });
      }
    }

    // Validate enableClientCertificate if present
    if (
      props.properties.enableClientCertificate !== undefined &&
      typeof props.properties.enableClientCertificate !== 'boolean'
    ) {
      errors.push({
        path: 'properties.enableClientCertificate',
        message: 'Property "properties.enableClientCertificate" must be a boolean',
        code: 'INVALID_TYPE',
        fix: 'Use true or false',
      });
    }

    // Validate disableGateway if present
    if (
      props.properties.disableGateway !== undefined &&
      typeof props.properties.disableGateway !== 'boolean'
    ) {
      errors.push({
        path: 'properties.disableGateway',
        message: 'Property "properties.disableGateway" must be a boolean',
        code: 'INVALID_TYPE',
        fix: 'Use true or false',
      });
    }

    // Validate natGatewayState if present
    if (props.properties.natGatewayState !== undefined) {
      const validValues = ['Enabled', 'Disabled'];
      if (!validValues.includes(props.properties.natGatewayState)) {
        errors.push({
          path: 'properties.natGatewayState',
          message: `Property "properties.natGatewayState" must be one of: ${validValues.join(', ')}. Got: "${props.properties.natGatewayState}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: 'Choose either "Enabled" or "Disabled"',
        });
      }
    }
  }

  // Validate tags if present
  if (props.tags !== undefined) {
    if (typeof props.tags !== 'object' || Array.isArray(props.tags)) {
      errors.push({
        path: 'tags',
        message: 'Property "tags" must be an object with string key-value pairs',
        code: 'INVALID_TYPE',
        fix: 'Provide an object with string keys and values, e.g., { environment: "production" }',
      });
    }
  }

  // Validate identity if present
  if (props.identity !== undefined) {
    if (props.identity.type === undefined) {
      errors.push({
        path: 'identity.type',
        message: 'Required property "identity.type" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add the "type" property (None, SystemAssigned, UserAssigned, or "SystemAssigned, UserAssigned")',
      });
    } else {
      const validTypes = ['None', 'SystemAssigned', 'UserAssigned', 'SystemAssigned, UserAssigned'];
      if (!validTypes.includes(props.identity.type)) {
        errors.push({
          path: 'identity.type',
          message: `Property "identity.type" must be one of: ${validTypes.map((t) => `"${t}"`).join(', ')}. Got: "${props.identity.type}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose a valid identity type: ${validTypes.map((t) => `"${t}"`).join(', ')}`,
        });
      }
    }
  }

  // Validate zones if present
  if (props.zones !== undefined) {
    if (!Array.isArray(props.zones)) {
      errors.push({
        path: 'zones',
        message: 'Property "zones" must be an array',
        code: 'INVALID_TYPE',
        fix: 'Provide an array of zone identifiers (e.g., ["1", "2", "3"])',
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate Microsoft.ApiManagement/service/apis properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validateApiManagementServiceApis(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required property: name
  if (props.name === undefined || props.name === null) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your API definition',
    });
  } else {
    if (typeof props.name !== 'string') {
      errors.push({
        path: 'name',
        message: 'Property "name" must be a string',
        code: 'INVALID_TYPE',
        fix: 'Ensure "name" is a string value',
      });
    } else {
      // Validate name length
      if (props.name.length < 1 || props.name.length > 256) {
        errors.push({
          path: 'name',
          message: `Property "name" must be between 1 and 256 characters, got ${props.name.length}`,
          code: 'INVALID_LENGTH',
          fix: 'Use an API identifier between 1 and 256 characters',
        });
      }

      // Validate name pattern
      if (!API_ID_PATTERN.test(props.name)) {
        errors.push({
          path: 'name',
          message: `Property "name" cannot contain: * # & + : < > ?. Got: "${props.name}"`,
          code: 'INVALID_PATTERN',
          fix: 'Remove invalid characters from the API identifier',
        });
      }
    }
  }

  // Validate required property: properties
  if (props.properties === undefined || props.properties === null) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with API configuration',
    });
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate Microsoft.ApiManagement/service/products properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validateApiManagementServiceProducts(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required property: name
  if (props.name === undefined || props.name === null) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your product definition',
    });
  } else if (typeof props.name !== 'string') {
    errors.push({
      path: 'name',
      message: 'Property "name" must be a string',
      code: 'INVALID_TYPE',
      fix: 'Ensure "name" is a string value',
    });
  } else if (props.name.length < 1 || props.name.length > 256) {
    errors.push({
      path: 'name',
      message: `Property "name" must be between 1 and 256 characters, got ${props.name.length}`,
      code: 'INVALID_LENGTH',
      fix: 'Use a product identifier between 1 and 256 characters',
    });
  }

  // Validate required property: properties
  if (props.properties === undefined || props.properties === null) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with product configuration',
    });
  } else {
    // Validate required property: displayName
    if (props.properties.displayName === undefined || props.properties.displayName === null) {
      errors.push({
        path: 'properties.displayName',
        message: 'Required property "properties.displayName" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add the "displayName" property with the product display name',
      });
    } else if (typeof props.properties.displayName !== 'string') {
      errors.push({
        path: 'properties.displayName',
        message: 'Property "properties.displayName" must be a string',
        code: 'INVALID_TYPE',
        fix: 'Provide a valid display name string',
      });
    } else if (props.properties.displayName.length < 1 || props.properties.displayName.length > 300) {
      errors.push({
        path: 'properties.displayName',
        message: `Property "properties.displayName" must be between 1 and 300 characters, got ${props.properties.displayName.length}`,
        code: 'INVALID_LENGTH',
        fix: 'Use a display name between 1 and 300 characters',
      });
    }

    // Validate state if present
    if (props.properties.state !== undefined) {
      const validStates = ['notPublished', 'published'];
      if (!validStates.includes(props.properties.state)) {
        errors.push({
          path: 'properties.state',
          message: `Property "properties.state" must be one of: ${validStates.join(', ')}. Got: "${props.properties.state}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose a valid product state: ${validStates.join(', ')}`,
        });
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
