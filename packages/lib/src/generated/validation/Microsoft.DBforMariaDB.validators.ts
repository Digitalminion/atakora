/**
 * Runtime validators for Microsoft.DBforMariaDB resources.
 *
 * **API Version**: 2018-06-01
 * **Generated**: 2025-10-13T00:00:00.000Z
 *
 * @remarks
 * This file is auto-generated. Do not edit manually.
 * Generated by Felix (Schema & Validation Engineer)
 *
 * @packageDocumentation
 */

/**
 * Validation error.
 */
export interface ValidationError {
  readonly path: string;
  readonly message: string;
  readonly code: string;
  readonly fix?: string;
}

/**
 * Validation result.
 */
export interface ValidationResult {
  readonly valid: boolean;
  readonly errors: ValidationError[];
}

/**
 * Validate server name format.
 *
 * @param name - Server name to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateServerName(name: string, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!name) {
    errors.push({
      path,
      message: 'Server name is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide a server name',
    });
    return errors;
  }

  if (name.length < 3 || name.length > 63) {
    errors.push({
      path,
      message: `Server name length must be between 3 and 63 characters, got ${name.length}`,
      code: 'INVALID_LENGTH',
      fix: 'Use a server name between 3 and 63 characters',
    });
  }

  const namePattern = /^[a-z][a-z0-9-]*[a-z0-9]$/;
  if (!namePattern.test(name)) {
    errors.push({
      path,
      message: `Server name must start with a letter, contain only lowercase letters, numbers, and hyphens, and cannot end with a hyphen. Got: "${name}"`,
      code: 'INVALID_PATTERN',
      fix: 'Use only lowercase letters, numbers, and hyphens. Start with a letter and do not end with a hyphen',
    });
  }

  return errors;
}

/**
 * Validate IP address format.
 *
 * @param ip - IP address to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateIpAddress(ip: string, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!ip) {
    errors.push({
      path,
      message: 'IP address is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide an IP address',
    });
    return errors;
  }

  const ipPattern = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (!ipPattern.test(ip)) {
    errors.push({
      path,
      message: `Invalid IPv4 address format: "${ip}"`,
      code: 'INVALID_IP_FORMAT',
      fix: 'Use valid IPv4 format (e.g., "192.168.1.1")',
    });
    return errors;
  }

  const octets = ip.split('.');
  for (let i = 0; i < octets.length; i++) {
    const octet = parseInt(octets[i], 10);
    if (octet < 0 || octet > 255) {
      errors.push({
        path,
        message: `IP address octet must be between 0 and 255, got ${octet} in "${ip}"`,
        code: 'INVALID_IP_OCTET',
        fix: 'Ensure each octet is between 0 and 255',
      });
      break;
    }
  }

  return errors;
}

/**
 * Validate ISO 8601 date-time format.
 *
 * @param dateTime - Date-time string to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateIso8601DateTime(dateTime: string, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!dateTime) {
    errors.push({
      path,
      message: 'Date-time is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide an ISO 8601 date-time string',
    });
    return errors;
  }

  const iso8601Pattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:\d{2})$/;
  if (!iso8601Pattern.test(dateTime)) {
    errors.push({
      path,
      message: `Invalid ISO 8601 date-time format: "${dateTime}"`,
      code: 'INVALID_DATETIME_FORMAT',
      fix: 'Use ISO 8601 format (e.g., "2024-10-13T12:00:00Z")',
    });
    return errors;
  }

  const date = new Date(dateTime);
  if (isNaN(date.getTime())) {
    errors.push({
      path,
      message: `Invalid date-time value: "${dateTime}"`,
      code: 'INVALID_DATETIME_VALUE',
      fix: 'Provide a valid date-time',
    });
  }

  return errors;
}

/**
 * Validate MariaDB SKU.
 *
 * @param sku - SKU to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateSku(sku: any, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!sku) {
    return errors;
  }

  if (!sku.name) {
    errors.push({
      path: `${path}.name`,
      message: 'SKU name is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Provide a SKU name (e.g., "B_Gen5_1", "GP_Gen5_2")',
    });
  }

  if (sku.capacity !== undefined) {
    if (typeof sku.capacity !== 'number' || sku.capacity < 0) {
      errors.push({
        path: `${path}.capacity`,
        message: `SKU capacity must be a non-negative number, got ${sku.capacity}`,
        code: 'INVALID_VALUE',
        fix: 'Use a non-negative number for capacity',
      });
    }
  }

  if (sku.tier !== undefined) {
    const validTiers = ['Basic', 'GeneralPurpose', 'MemoryOptimized'];
    if (!validTiers.includes(sku.tier)) {
      errors.push({
        path: `${path}.tier`,
        message: `SKU tier must be one of: ${validTiers.join(', ')}. Got: "${sku.tier}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validTiers.join(', ')}`,
      });
    }
  }

  return errors;
}

/**
 * Validate storage profile.
 *
 * @param storageProfile - Storage profile to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateStorageProfile(storageProfile: any, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!storageProfile) {
    return errors;
  }

  if (storageProfile.backupRetentionDays !== undefined) {
    const days = storageProfile.backupRetentionDays;
    if (typeof days !== 'number' || days < 7 || days > 35) {
      errors.push({
        path: `${path}.backupRetentionDays`,
        message: `Backup retention days must be between 7 and 35, got ${days}`,
        code: 'VALUE_OUT_OF_RANGE',
        fix: 'Set backup retention between 7 and 35 days',
      });
    }
  }

  if (storageProfile.storageMB !== undefined) {
    const storageMB = storageProfile.storageMB;
    if (typeof storageMB !== 'number' || storageMB < 5120 || storageMB > 1048576) {
      errors.push({
        path: `${path}.storageMB`,
        message: `Storage size must be between 5120 MB (5 GB) and 1048576 MB (1 TB), got ${storageMB}`,
        code: 'VALUE_OUT_OF_RANGE',
        fix: 'Set storage size between 5120 MB and 1048576 MB',
      });
    }
  }

  const validGeoRedundantValues = ['Disabled', 'Enabled'];
  if (storageProfile.geoRedundantBackup !== undefined) {
    if (!validGeoRedundantValues.includes(storageProfile.geoRedundantBackup)) {
      errors.push({
        path: `${path}.geoRedundantBackup`,
        message: `Geo-redundant backup must be one of: ${validGeoRedundantValues.join(', ')}. Got: "${storageProfile.geoRedundantBackup}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validGeoRedundantValues.join(', ')}`,
      });
    }
  }

  const validStorageAutogrowValues = ['Disabled', 'Enabled'];
  if (storageProfile.storageAutogrow !== undefined) {
    if (!validStorageAutogrowValues.includes(storageProfile.storageAutogrow)) {
      errors.push({
        path: `${path}.storageAutogrow`,
        message: `Storage auto-grow must be one of: ${validStorageAutogrowValues.join(', ')}. Got: "${storageProfile.storageAutogrow}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validStorageAutogrowValues.join(', ')}`,
      });
    }
  }

  return errors;
}

/**
 * Validate common server properties.
 *
 * @param properties - Server properties to validate
 * @param path - Property path for error reporting
 * @returns Validation errors if any
 */
function validateCommonServerProperties(properties: any, path: string): ValidationError[] {
  const errors: ValidationError[] = [];

  const validTlsVersions = ['TLS1_0', 'TLS1_1', 'TLS1_2', 'TLSEnforcementDisabled'];
  if (properties.minimalTlsVersion !== undefined) {
    if (!validTlsVersions.includes(properties.minimalTlsVersion)) {
      errors.push({
        path: `${path}.minimalTlsVersion`,
        message: `Minimal TLS version must be one of: ${validTlsVersions.join(', ')}. Got: "${properties.minimalTlsVersion}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validTlsVersions.join(', ')}`,
      });
    }
  }

  const validPublicNetworkAccessValues = ['Disabled', 'Enabled'];
  if (properties.publicNetworkAccess !== undefined) {
    if (!validPublicNetworkAccessValues.includes(properties.publicNetworkAccess)) {
      errors.push({
        path: `${path}.publicNetworkAccess`,
        message: `Public network access must be one of: ${validPublicNetworkAccessValues.join(', ')}. Got: "${properties.publicNetworkAccess}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validPublicNetworkAccessValues.join(', ')}`,
      });
    }
  }

  const validSslEnforcementValues = ['Disabled', 'Enabled'];
  if (properties.sslEnforcement !== undefined) {
    if (!validSslEnforcementValues.includes(properties.sslEnforcement)) {
      errors.push({
        path: `${path}.sslEnforcement`,
        message: `SSL enforcement must be one of: ${validSslEnforcementValues.join(', ')}. Got: "${properties.sslEnforcement}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validSslEnforcementValues.join(', ')}`,
      });
    }
  }

  const validVersions = ['10.2', '10.3'];
  if (properties.version !== undefined) {
    if (!validVersions.includes(properties.version)) {
      errors.push({
        path: `${path}.version`,
        message: `MariaDB version must be one of: ${validVersions.join(', ')}. Got: "${properties.version}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Use one of: ${validVersions.join(', ')}`,
      });
    }
  }

  if (properties.storageProfile) {
    errors.push(...validateStorageProfile(properties.storageProfile, `${path}.storageProfile`));
  }

  return errors;
}

/**
 * Validate Microsoft.DBforMariaDB/servers properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validateMariaDbServer(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required properties
  if (!props.name) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your resource definition',
    });
  } else {
    errors.push(...validateServerName(props.name, 'name'));
  }

  if (!props.location) {
    errors.push({
      path: 'location',
      message: 'Required property "location" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "location" property (e.g., "eastus", "westeurope")',
    });
  }

  if (!props.properties) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with server configuration',
    });
    return { valid: errors.length === 0, errors };
  }

  const properties = props.properties;

  if (!properties.createMode) {
    errors.push({
      path: 'properties.createMode',
      message: 'Required property "createMode" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add "createMode" property (Default, GeoRestore, PointInTimeRestore, or Replica)',
    });
    return { valid: errors.length === 0, errors };
  }

  // Validate based on create mode
  const validCreateModes = ['Default', 'GeoRestore', 'PointInTimeRestore', 'Replica'];
  if (!validCreateModes.includes(properties.createMode)) {
    errors.push({
      path: 'properties.createMode',
      message: `Create mode must be one of: ${validCreateModes.join(', ')}. Got: "${properties.createMode}"`,
      code: 'INVALID_ENUM_VALUE',
      fix: `Use one of: ${validCreateModes.join(', ')}`,
    });
    return { valid: errors.length === 0, errors };
  }

  // Validate common properties
  errors.push(...validateCommonServerProperties(properties, 'properties'));

  // Validate mode-specific properties
  switch (properties.createMode) {
    case 'Default':
      if (!properties.administratorLogin) {
        errors.push({
          path: 'properties.administratorLogin',
          message: 'Administrator login is required for Default create mode',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "administratorLogin" property with a valid username',
        });
      } else {
        const invalidUsernames = ['azure_superuser', 'admin', 'administrator', 'root', 'guest', 'public'];
        if (invalidUsernames.includes(properties.administratorLogin.toLowerCase())) {
          errors.push({
            path: 'properties.administratorLogin',
            message: `Administrator login cannot be: ${invalidUsernames.join(', ')}. Got: "${properties.administratorLogin}"`,
            code: 'INVALID_VALUE',
            fix: 'Use a different administrator username',
          });
        }
      }

      if (!properties.administratorLoginPassword) {
        errors.push({
          path: 'properties.administratorLoginPassword',
          message: 'Administrator login password is required for Default create mode',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "administratorLoginPassword" property with a strong password (8-128 characters)',
        });
      } else {
        const password = properties.administratorLoginPassword;
        if (password.length < 8 || password.length > 128) {
          errors.push({
            path: 'properties.administratorLoginPassword',
            message: `Administrator password length must be between 8 and 128 characters, got ${password.length}`,
            code: 'INVALID_LENGTH',
            fix: 'Use a password between 8 and 128 characters',
          });
        }
      }
      break;

    case 'GeoRestore':
      if (!properties.sourceServerId) {
        errors.push({
          path: 'properties.sourceServerId',
          message: 'Source server ID is required for GeoRestore create mode',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "sourceServerId" property with the resource ID of the source server',
        });
      }
      break;

    case 'PointInTimeRestore':
      if (!properties.sourceServerId) {
        errors.push({
          path: 'properties.sourceServerId',
          message: 'Source server ID is required for PointInTimeRestore create mode',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "sourceServerId" property with the resource ID of the source server',
        });
      }

      if (!properties.restorePointInTime) {
        errors.push({
          path: 'properties.restorePointInTime',
          message: 'Restore point in time is required for PointInTimeRestore create mode',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "restorePointInTime" property with an ISO 8601 date-time string',
        });
      } else {
        errors.push(...validateIso8601DateTime(properties.restorePointInTime, 'properties.restorePointInTime'));
      }
      break;

    case 'Replica':
      if (!properties.sourceServerId) {
        errors.push({
          path: 'properties.sourceServerId',
          message: 'Source server ID is required for Replica create mode',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "sourceServerId" property with the resource ID of the source server',
        });
      }
      break;
  }

  // Validate SKU if provided
  if (props.sku) {
    errors.push(...validateSku(props.sku, 'sku'));
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate Microsoft.DBforMariaDB/servers/databases properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validateMariaDbDatabase(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  if (!props.name) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your database definition',
    });
  } else {
    if (props.name.length < 1 || props.name.length > 63) {
      errors.push({
        path: 'name',
        message: `Database name length must be between 1 and 63 characters, got ${props.name.length}`,
        code: 'INVALID_LENGTH',
        fix: 'Use a database name between 1 and 63 characters',
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate Microsoft.DBforMariaDB/servers/firewallRules properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validateMariaDbFirewallRule(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  if (!props.name) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your firewall rule definition',
    });
  } else {
    if (props.name.length < 1 || props.name.length > 128) {
      errors.push({
        path: 'name',
        message: `Firewall rule name length must be between 1 and 128 characters, got ${props.name.length}`,
        code: 'INVALID_LENGTH',
        fix: 'Use a firewall rule name between 1 and 128 characters',
      });
    }
  }

  if (!props.properties) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with startIpAddress and endIpAddress',
    });
    return { valid: errors.length === 0, errors };
  }

  if (!props.properties.startIpAddress) {
    errors.push({
      path: 'properties.startIpAddress',
      message: 'Start IP address is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add "startIpAddress" property with a valid IPv4 address',
    });
  } else {
    errors.push(...validateIpAddress(props.properties.startIpAddress, 'properties.startIpAddress'));
  }

  if (!props.properties.endIpAddress) {
    errors.push({
      path: 'properties.endIpAddress',
      message: 'End IP address is required',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add "endIpAddress" property with a valid IPv4 address',
    });
  } else {
    errors.push(...validateIpAddress(props.properties.endIpAddress, 'properties.endIpAddress'));
  }

  // Validate IP range if both IPs are valid
  if (props.properties.startIpAddress && props.properties.endIpAddress) {
    const startErrors = validateIpAddress(props.properties.startIpAddress, 'properties.startIpAddress');
    const endErrors = validateIpAddress(props.properties.endIpAddress, 'properties.endIpAddress');

    if (startErrors.length === 0 && endErrors.length === 0) {
      const startOctets = props.properties.startIpAddress.split('.').map((o: string) => parseInt(o, 10));
      const endOctets = props.properties.endIpAddress.split('.').map((o: string) => parseInt(o, 10));

      const startValue = (startOctets[0] << 24) + (startOctets[1] << 16) + (startOctets[2] << 8) + startOctets[3];
      const endValue = (endOctets[0] << 24) + (endOctets[1] << 16) + (endOctets[2] << 8) + endOctets[3];

      if (startValue > endValue) {
        errors.push({
          path: 'properties',
          message: `Start IP address (${props.properties.startIpAddress}) must be less than or equal to end IP address (${props.properties.endIpAddress})`,
          code: 'INVALID_IP_RANGE',
          fix: 'Ensure startIpAddress is less than or equal to endIpAddress',
        });
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
