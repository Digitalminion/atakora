/**
 * Runtime validators for Microsoft.Consumption (Azure Cost Management) resources.
 *
 * **API Version**: 2023-11-01
 * **Generated**: 2025-10-13
 *
 * @remarks
 * This file is auto-generated. Do not edit manually.
 * Generated by Felix (Schema & Validation Engineer)
 *
 * @packageDocumentation
 */

/**
 * Validation error.
 */
export interface ValidationError {
  readonly path: string;
  readonly message: string;
  readonly code: string;
  readonly fix?: string;
}

/**
 * Validation result.
 */
export interface ValidationResult {
  readonly valid: boolean;
  readonly errors: ValidationError[];
}

/**
 * Valid budget time grains.
 */
const VALID_TIME_GRAINS = [
  'Annually',
  'Monthly',
  'Quarterly',
  'BillingMonth',
  'BillingQuarter',
  'BillingAnnual',
];

/**
 * Valid notification operators.
 */
const VALID_NOTIFICATION_OPERATORS = ['EqualTo', 'GreaterThan', 'GreaterThanOrEqualTo'];

/**
 * Valid threshold types.
 */
const VALID_THRESHOLD_TYPES = ['Actual', 'Forecasted'];

/**
 * Valid notification locales.
 */
const VALID_NOTIFICATION_LOCALES = [
  'en-us',
  'ja-jp',
  'zh-cn',
  'de-de',
  'es-es',
  'fr-fr',
  'it-it',
  'ko-kr',
  'pt-br',
  'ru-ru',
  'zh-tw',
  'cs-cz',
  'pl-pl',
  'tr-tr',
  'da-dk',
  'en-gb',
  'hu-hu',
  'nb-no',
  'nl-nl',
  'pt-pt',
  'sv-se',
];

/**
 * ISO 8601 date pattern (YYYY-MM-DD).
 */
const ISO_DATE_PATTERN = /^\d{4}-\d{2}-\d{2}$/;

/**
 * Email address pattern.
 */
const EMAIL_PATTERN = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

/**
 * Action group resource ID pattern.
 */
const ACTION_GROUP_ID_PATTERN =
  /^\/subscriptions\/[a-fA-F0-9-]{36}\/resourceGroups\/[\w.-]+\/providers\/Microsoft\.Insights\/actionGroups\/[\w.-]+$/;

/**
 * Common Azure RBAC roles for budget notifications.
 */
const COMMON_CONTACT_ROLES = [
  'Owner',
  'Contributor',
  'Reader',
  'Cost Management Contributor',
  'Cost Management Reader',
];

/**
 * Validate Microsoft.Consumption/budgets properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 *
 * @example
 * ```typescript
 * const result = validateBudget({
 *   name: 'MonthlyBudget',
 *   properties: {
 *     amount: 10000,
 *     category: 'Cost',
 *     timeGrain: 'Monthly',
 *     timePeriod: {
 *       startDate: '2024-01-01'
 *     },
 *     notifications: {
 *       'Alert80Percent': {
 *         enabled: true,
 *         threshold: 80,
 *         operator: 'GreaterThan',
 *         contactEmails: ['admin@contoso.com']
 *       }
 *     }
 *   }
 * });
 *
 * if (!result.valid) {
 *   result.errors.forEach(err => console.error(err.message));
 * }
 * ```
 */
export function validateBudget(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required property: name
  if (props.name === undefined || props.name === null) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your budget definition',
    });
  } else if (typeof props.name !== 'string') {
    errors.push({
      path: 'name',
      message: 'Property "name" must be a string',
      code: 'INVALID_TYPE',
      fix: 'Ensure "name" is a string value (e.g., "MonthlyBudget")',
    });
  } else if (props.name.length === 0) {
    errors.push({
      path: 'name',
      message: 'Property "name" cannot be empty',
      code: 'INVALID_LENGTH',
      fix: 'Provide a non-empty budget name',
    });
  }

  // Validate required property: properties
  if (props.properties === undefined || props.properties === null) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with budget configuration',
    });
  } else {
    const properties = props.properties;

    // Validate required property: properties.amount
    if (properties.amount === undefined || properties.amount === null) {
      errors.push({
        path: 'properties.amount',
        message: 'Required property "properties.amount" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add the budget amount as a positive number (e.g., 10000)',
      });
    } else if (typeof properties.amount !== 'number') {
      errors.push({
        path: 'properties.amount',
        message: 'Property "properties.amount" must be a number',
        code: 'INVALID_TYPE',
        fix: 'Ensure "amount" is a numeric value',
      });
    } else if (properties.amount <= 0) {
      errors.push({
        path: 'properties.amount',
        message: `Property "properties.amount" must be positive. Got: ${properties.amount}`,
        code: 'INVALID_VALUE',
        fix: 'Provide a positive budget amount greater than 0',
      });
    } else if (!Number.isInteger(properties.amount)) {
      errors.push({
        path: 'properties.amount',
        message: `Property "properties.amount" must be an integer. Got: ${properties.amount}`,
        code: 'INVALID_VALUE',
        fix: 'Round the amount to an integer value',
      });
    }

    // Validate required property: properties.category
    if (properties.category === undefined || properties.category === null) {
      errors.push({
        path: 'properties.category',
        message: 'Required property "properties.category" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add "category" property with value "Cost"',
      });
    } else if (properties.category !== 'Cost') {
      errors.push({
        path: 'properties.category',
        message: `Property "properties.category" must be "Cost". Got: "${properties.category}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: 'Set category to "Cost" (currently the only supported value)',
      });
    }

    // Validate required property: properties.timeGrain
    if (properties.timeGrain === undefined || properties.timeGrain === null) {
      errors.push({
        path: 'properties.timeGrain',
        message: 'Required property "properties.timeGrain" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: `Add "timeGrain" property. Valid values: ${VALID_TIME_GRAINS.join(', ')}`,
      });
    } else if (!VALID_TIME_GRAINS.includes(properties.timeGrain)) {
      errors.push({
        path: 'properties.timeGrain',
        message: `Property "properties.timeGrain" must be one of: ${VALID_TIME_GRAINS.join(', ')}. Got: "${properties.timeGrain}"`,
        code: 'INVALID_ENUM_VALUE',
        fix: `Choose a valid time grain: ${VALID_TIME_GRAINS.join(', ')}`,
      });
    }

    // Validate required property: properties.timePeriod
    if (properties.timePeriod === undefined || properties.timePeriod === null) {
      errors.push({
        path: 'properties.timePeriod',
        message: 'Required property "properties.timePeriod" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add "timePeriod" object with at least "startDate"',
      });
    } else {
      const timePeriod = properties.timePeriod;

      // Validate required property: timePeriod.startDate
      if (timePeriod.startDate === undefined || timePeriod.startDate === null) {
        errors.push({
          path: 'properties.timePeriod.startDate',
          message: 'Required property "properties.timePeriod.startDate" is missing',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "startDate" in ISO 8601 format (YYYY-MM-DD), e.g., "2024-01-01"',
        });
      } else if (typeof timePeriod.startDate !== 'string') {
        errors.push({
          path: 'properties.timePeriod.startDate',
          message: 'Property "properties.timePeriod.startDate" must be a string',
          code: 'INVALID_TYPE',
          fix: 'Provide start date as a string in format YYYY-MM-DD',
        });
      } else if (!ISO_DATE_PATTERN.test(timePeriod.startDate)) {
        errors.push({
          path: 'properties.timePeriod.startDate',
          message: `Property "properties.timePeriod.startDate" must be in ISO 8601 format (YYYY-MM-DD). Got: "${timePeriod.startDate}"`,
          code: 'INVALID_PATTERN',
          fix: 'Use format YYYY-MM-DD, e.g., "2024-01-01"',
        });
      } else {
        // Validate date is valid
        const startDate = new Date(timePeriod.startDate);
        if (isNaN(startDate.getTime())) {
          errors.push({
            path: 'properties.timePeriod.startDate',
            message: `Property "properties.timePeriod.startDate" is not a valid date: "${timePeriod.startDate}"`,
            code: 'INVALID_DATE',
            fix: 'Provide a valid calendar date in format YYYY-MM-DD',
          });
        }
      }

      // Validate optional property: timePeriod.endDate
      if (timePeriod.endDate !== undefined) {
        if (typeof timePeriod.endDate !== 'string') {
          errors.push({
            path: 'properties.timePeriod.endDate',
            message: 'Property "properties.timePeriod.endDate" must be a string',
            code: 'INVALID_TYPE',
            fix: 'Provide end date as a string in format YYYY-MM-DD',
          });
        } else if (!ISO_DATE_PATTERN.test(timePeriod.endDate)) {
          errors.push({
            path: 'properties.timePeriod.endDate',
            message: `Property "properties.timePeriod.endDate" must be in ISO 8601 format (YYYY-MM-DD). Got: "${timePeriod.endDate}"`,
            code: 'INVALID_PATTERN',
            fix: 'Use format YYYY-MM-DD, e.g., "2024-12-31"',
          });
        } else {
          // Validate date is valid
          const endDate = new Date(timePeriod.endDate);
          if (isNaN(endDate.getTime())) {
            errors.push({
              path: 'properties.timePeriod.endDate',
              message: `Property "properties.timePeriod.endDate" is not a valid date: "${timePeriod.endDate}"`,
              code: 'INVALID_DATE',
              fix: 'Provide a valid calendar date in format YYYY-MM-DD',
            });
          } else if (timePeriod.startDate) {
            // Validate end date is after start date
            const startDate = new Date(timePeriod.startDate);
            if (endDate <= startDate) {
              errors.push({
                path: 'properties.timePeriod.endDate',
                message: `Property "properties.timePeriod.endDate" must be after startDate. Start: "${timePeriod.startDate}", End: "${timePeriod.endDate}"`,
                code: 'INVALID_DATE_RANGE',
                fix: 'Ensure end date is after start date',
              });
            }
          }
        }
      }
    }

    // Validate optional property: properties.filter
    if (properties.filter !== undefined) {
      const filter = properties.filter;

      // Validate filter.dimensions if present
      if (filter.dimensions !== undefined) {
        if (!filter.dimensions.name) {
          errors.push({
            path: 'properties.filter.dimensions.name',
            message: 'Dimension filter must have a "name" property',
            code: 'REQUIRED_PROPERTY_MISSING',
            fix: 'Add dimension name (e.g., "ResourceGroupName", "ResourceType")',
          });
        } else if (typeof filter.dimensions.name !== 'string') {
          errors.push({
            path: 'properties.filter.dimensions.name',
            message: 'Dimension name must be a string',
            code: 'INVALID_TYPE',
            fix: 'Provide dimension name as a string',
          });
        }

        if (!filter.dimensions.values) {
          errors.push({
            path: 'properties.filter.dimensions.values',
            message: 'Dimension filter must have a "values" array',
            code: 'REQUIRED_PROPERTY_MISSING',
            fix: 'Add array of dimension values to filter by',
          });
        } else if (!Array.isArray(filter.dimensions.values)) {
          errors.push({
            path: 'properties.filter.dimensions.values',
            message: 'Dimension values must be an array',
            code: 'INVALID_TYPE',
            fix: 'Provide dimension values as an array of strings',
          });
        } else if (filter.dimensions.values.length === 0) {
          errors.push({
            path: 'properties.filter.dimensions.values',
            message: 'Dimension values array cannot be empty',
            code: 'ARRAY_MIN_LENGTH',
            fix: 'Add at least one dimension value',
          });
        }

        if (filter.dimensions.operator !== undefined && filter.dimensions.operator !== 'In') {
          errors.push({
            path: 'properties.filter.dimensions.operator',
            message: `Dimension operator must be "In". Got: "${filter.dimensions.operator}"`,
            code: 'INVALID_ENUM_VALUE',
            fix: 'Set operator to "In" or omit it (defaults to "In")',
          });
        }
      }

      // Validate filter.tags if present
      if (filter.tags !== undefined) {
        if (!filter.tags.name) {
          errors.push({
            path: 'properties.filter.tags.name',
            message: 'Tag filter must have a "name" property',
            code: 'REQUIRED_PROPERTY_MISSING',
            fix: 'Add tag name (e.g., "Environment", "CostCenter")',
          });
        } else if (typeof filter.tags.name !== 'string') {
          errors.push({
            path: 'properties.filter.tags.name',
            message: 'Tag name must be a string',
            code: 'INVALID_TYPE',
            fix: 'Provide tag name as a string',
          });
        }

        if (!filter.tags.values) {
          errors.push({
            path: 'properties.filter.tags.values',
            message: 'Tag filter must have a "values" array',
            code: 'REQUIRED_PROPERTY_MISSING',
            fix: 'Add array of tag values to filter by',
          });
        } else if (!Array.isArray(filter.tags.values)) {
          errors.push({
            path: 'properties.filter.tags.values',
            message: 'Tag values must be an array',
            code: 'INVALID_TYPE',
            fix: 'Provide tag values as an array of strings',
          });
        } else if (filter.tags.values.length === 0) {
          errors.push({
            path: 'properties.filter.tags.values',
            message: 'Tag values array cannot be empty',
            code: 'ARRAY_MIN_LENGTH',
            fix: 'Add at least one tag value',
          });
        }

        if (filter.tags.operator !== undefined && filter.tags.operator !== 'In') {
          errors.push({
            path: 'properties.filter.tags.operator',
            message: `Tag operator must be "In". Got: "${filter.tags.operator}"`,
            code: 'INVALID_ENUM_VALUE',
            fix: 'Set operator to "In" or omit it (defaults to "In")',
          });
        }
      }

      // Validate filter.and if present
      if (filter.and !== undefined) {
        if (!Array.isArray(filter.and)) {
          errors.push({
            path: 'properties.filter.and',
            message: 'Filter "and" must be an array',
            code: 'INVALID_TYPE',
            fix: 'Provide "and" as an array of filter conditions',
          });
        } else if (filter.and.length === 0) {
          errors.push({
            path: 'properties.filter.and',
            message: 'Filter "and" array cannot be empty',
            code: 'ARRAY_MIN_LENGTH',
            fix: 'Add at least one filter condition or remove the "and" property',
          });
        }
      }
    }

    // Validate optional property: properties.notifications
    if (properties.notifications !== undefined) {
      if (typeof properties.notifications !== 'object' || Array.isArray(properties.notifications)) {
        errors.push({
          path: 'properties.notifications',
          message: 'Property "properties.notifications" must be an object',
          code: 'INVALID_TYPE',
          fix: 'Provide notifications as an object with notification names as keys',
        });
      } else {
        const notificationNames = Object.keys(properties.notifications);

        if (notificationNames.length === 0) {
          errors.push({
            path: 'properties.notifications',
            message: 'At least one notification is recommended',
            code: 'MISSING_NOTIFICATIONS',
            fix: 'Add at least one notification to receive budget alerts',
          });
        }

        // Validate each notification
        notificationNames.forEach((notificationName) => {
          const notification = properties.notifications[notificationName];
          const basePath = `properties.notifications.${notificationName}`;

          // Validate required property: enabled
          if (notification.enabled === undefined || notification.enabled === null) {
            errors.push({
              path: `${basePath}.enabled`,
              message: `Required property "${basePath}.enabled" is missing`,
              code: 'REQUIRED_PROPERTY_MISSING',
              fix: 'Add "enabled" property (true or false)',
            });
          } else if (typeof notification.enabled !== 'boolean') {
            errors.push({
              path: `${basePath}.enabled`,
              message: `Property "${basePath}.enabled" must be a boolean`,
              code: 'INVALID_TYPE',
              fix: 'Set to true or false',
            });
          }

          // Validate required property: threshold
          if (notification.threshold === undefined || notification.threshold === null) {
            errors.push({
              path: `${basePath}.threshold`,
              message: `Required property "${basePath}.threshold" is missing`,
              code: 'REQUIRED_PROPERTY_MISSING',
              fix: 'Add threshold value (0-1000, representing percentage)',
            });
          } else if (typeof notification.threshold !== 'number') {
            errors.push({
              path: `${basePath}.threshold`,
              message: `Property "${basePath}.threshold" must be a number`,
              code: 'INVALID_TYPE',
              fix: 'Provide threshold as a numeric value',
            });
          } else if (notification.threshold < 0 || notification.threshold > 1000) {
            errors.push({
              path: `${basePath}.threshold`,
              message: `Property "${basePath}.threshold" must be between 0 and 1000. Got: ${notification.threshold}`,
              code: 'OUT_OF_RANGE',
              fix: 'Set threshold to a value between 0 and 1000 (e.g., 80 for 80%)',
            });
          }

          // Validate required property: operator
          if (notification.operator === undefined || notification.operator === null) {
            errors.push({
              path: `${basePath}.operator`,
              message: `Required property "${basePath}.operator" is missing`,
              code: 'REQUIRED_PROPERTY_MISSING',
              fix: `Add operator. Valid values: ${VALID_NOTIFICATION_OPERATORS.join(', ')}`,
            });
          } else if (!VALID_NOTIFICATION_OPERATORS.includes(notification.operator)) {
            errors.push({
              path: `${basePath}.operator`,
              message: `Property "${basePath}.operator" must be one of: ${VALID_NOTIFICATION_OPERATORS.join(', ')}. Got: "${notification.operator}"`,
              code: 'INVALID_ENUM_VALUE',
              fix: `Choose a valid operator: ${VALID_NOTIFICATION_OPERATORS.join(', ')}`,
            });
          }

          // Validate required property: contactEmails
          if (notification.contactEmails === undefined || notification.contactEmails === null) {
            errors.push({
              path: `${basePath}.contactEmails`,
              message: `Required property "${basePath}.contactEmails" is missing`,
              code: 'REQUIRED_PROPERTY_MISSING',
              fix: 'Add array of email addresses to notify',
            });
          } else if (!Array.isArray(notification.contactEmails)) {
            errors.push({
              path: `${basePath}.contactEmails`,
              message: `Property "${basePath}.contactEmails" must be an array`,
              code: 'INVALID_TYPE',
              fix: 'Provide contact emails as an array of strings',
            });
          } else {
            if (notification.contactEmails.length === 0 &&
                (!notification.contactRoles || notification.contactRoles.length === 0) &&
                (!notification.contactGroups || notification.contactGroups.length === 0)) {
              errors.push({
                path: `${basePath}.contactEmails`,
                message: 'At least one contact method (email, role, or action group) is required',
                code: 'NO_CONTACTS',
                fix: 'Add at least one email address, contact role, or action group',
              });
            }

            if (notification.contactEmails.length > 50) {
              errors.push({
                path: `${basePath}.contactEmails`,
                message: `Maximum 50 email addresses allowed. Got: ${notification.contactEmails.length}`,
                code: 'ARRAY_MAX_LENGTH',
                fix: 'Reduce number of contact emails to 50 or fewer',
              });
            }

            // Validate each email address
            notification.contactEmails.forEach((email: any, index: number) => {
              if (typeof email !== 'string') {
                errors.push({
                  path: `${basePath}.contactEmails[${index}]`,
                  message: `Email at index ${index} must be a string`,
                  code: 'INVALID_TYPE',
                  fix: 'Provide valid email address strings',
                });
              } else if (!EMAIL_PATTERN.test(email)) {
                errors.push({
                  path: `${basePath}.contactEmails[${index}]`,
                  message: `Invalid email address format: "${email}"`,
                  code: 'INVALID_PATTERN',
                  fix: 'Provide valid email addresses (e.g., "user@contoso.com")',
                });
              }
            });
          }

          // Validate optional property: thresholdType
          if (notification.thresholdType !== undefined) {
            if (!VALID_THRESHOLD_TYPES.includes(notification.thresholdType)) {
              errors.push({
                path: `${basePath}.thresholdType`,
                message: `Property "${basePath}.thresholdType" must be one of: ${VALID_THRESHOLD_TYPES.join(', ')}. Got: "${notification.thresholdType}"`,
                code: 'INVALID_ENUM_VALUE',
                fix: `Choose either "Actual" or "Forecasted"`,
              });
            }
          }

          // Validate optional property: contactRoles
          if (notification.contactRoles !== undefined) {
            if (!Array.isArray(notification.contactRoles)) {
              errors.push({
                path: `${basePath}.contactRoles`,
                message: `Property "${basePath}.contactRoles" must be an array`,
                code: 'INVALID_TYPE',
                fix: 'Provide contact roles as an array of strings',
              });
            } else {
              notification.contactRoles.forEach((role: any, index: number) => {
                if (typeof role !== 'string') {
                  errors.push({
                    path: `${basePath}.contactRoles[${index}]`,
                    message: `Role at index ${index} must be a string`,
                    code: 'INVALID_TYPE',
                    fix: 'Provide valid role name strings',
                  });
                } else if (!COMMON_CONTACT_ROLES.includes(role)) {
                  // This is a warning, not an error - custom roles might exist
                  errors.push({
                    path: `${basePath}.contactRoles[${index}]`,
                    message: `Role "${role}" is not a common contact role`,
                    code: 'UNCOMMON_VALUE',
                    fix: `Common roles include: ${COMMON_CONTACT_ROLES.join(', ')}. Verify this role exists in your subscription.`,
                  });
                }
              });
            }
          }

          // Validate optional property: contactGroups
          if (notification.contactGroups !== undefined) {
            if (!Array.isArray(notification.contactGroups)) {
              errors.push({
                path: `${basePath}.contactGroups`,
                message: `Property "${basePath}.contactGroups" must be an array`,
                code: 'INVALID_TYPE',
                fix: 'Provide contact groups as an array of action group resource IDs',
              });
            } else {
              notification.contactGroups.forEach((groupId: any, index: number) => {
                if (typeof groupId !== 'string') {
                  errors.push({
                    path: `${basePath}.contactGroups[${index}]`,
                    message: `Action group ID at index ${index} must be a string`,
                    code: 'INVALID_TYPE',
                    fix: 'Provide valid action group resource ID strings',
                  });
                } else if (!ACTION_GROUP_ID_PATTERN.test(groupId)) {
                  errors.push({
                    path: `${basePath}.contactGroups[${index}]`,
                    message: `Invalid action group resource ID: "${groupId}"`,
                    code: 'INVALID_PATTERN',
                    fix: 'Use format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Insights/actionGroups/{actionGroupName}',
                  });
                }
              });
            }
          }

          // Validate optional property: locale
          if (notification.locale !== undefined) {
            if (!VALID_NOTIFICATION_LOCALES.includes(notification.locale)) {
              errors.push({
                path: `${basePath}.locale`,
                message: `Property "${basePath}.locale" must be one of: ${VALID_NOTIFICATION_LOCALES.join(', ')}. Got: "${notification.locale}"`,
                code: 'INVALID_ENUM_VALUE',
                fix: `Choose a valid locale code. Common: en-us, ja-jp, de-de, fr-fr`,
              });
            }
          }
        });
      }
    }
  }

  // Validate optional property: eTag
  if (props.eTag !== undefined && typeof props.eTag !== 'string') {
    errors.push({
      path: 'eTag',
      message: 'Property "eTag" must be a string',
      code: 'INVALID_TYPE',
      fix: 'Ensure "eTag" is a string value',
    });
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
