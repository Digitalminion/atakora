/**
 * Runtime validators for Microsoft.AAD (Azure Active Directory Domain Services) resources.
 *
 * **API Version**: 2025-06-01
 * **Generated**: 2025-10-13
 *
 * @remarks
 * This file is auto-generated. Do not edit manually.
 * Generated by Felix (Schema & Validation Engineer)
 *
 * @packageDocumentation
 */

/**
 * Validation error.
 */
export interface ValidationError {
  readonly path: string;
  readonly message: string;
  readonly code: string;
  readonly fix?: string;
}

/**
 * Validation result.
 */
export interface ValidationResult {
  readonly valid: boolean;
  readonly errors: ValidationError[];
}

/**
 * Domain name pattern for Microsoft.AAD/domainServices.
 *
 * @remarks
 * Must be a valid DNS name format with 3-255 characters.
 * Pattern: ^(?=.{3,255}$)([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)(\.([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?))*$
 */
const DOMAIN_NAME_PATTERN =
  /^(?=.{3,255}$)([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)(\.([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?))*$/;

/**
 * Subnet ID pattern for Azure resource IDs.
 */
const SUBNET_ID_PATTERN =
  /^\/subscriptions\/[a-fA-F0-9-]{36}\/resourceGroups\/[\w.-]+\/providers\/Microsoft\.Network\/virtualNetworks\/[\w.-]+\/subnets\/[\w.-]+$/;

/**
 * Email address pattern for notification recipients.
 */
const EMAIL_PATTERN = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

/**
 * Azure GUID pattern.
 */
const GUID_PATTERN = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;

/**
 * Validate Microsoft.AAD/domainServices properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 *
 * @example
 * ```typescript
 * const result = validateDomainServices({
 *   name: 'contoso.com',
 *   location: 'westus2',
 *   properties: {
 *     domainName: 'contoso.com',
 *     sku: 'Enterprise'
 *   }
 * });
 *
 * if (!result.valid) {
 *   result.errors.forEach(err => console.error(err.message));
 * }
 * ```
 */
export function validateDomainServices(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required property: name
  if (props.name === undefined || props.name === null) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your domain service definition',
    });
  } else {
    // Validate name format
    if (typeof props.name !== 'string') {
      errors.push({
        path: 'name',
        message: 'Property "name" must be a string',
        code: 'INVALID_TYPE',
        fix: 'Ensure "name" is a string value',
      });
    } else {
      // Validate name length
      if (props.name.length < 3 || props.name.length > 255) {
        errors.push({
          path: 'name',
          message: `Property "name" must be between 3 and 255 characters, got ${props.name.length}`,
          code: 'INVALID_LENGTH',
          fix: 'Use a domain name between 3 and 255 characters. Example: "contoso.com"',
        });
      }

      // Validate name pattern
      if (!DOMAIN_NAME_PATTERN.test(props.name)) {
        errors.push({
          path: 'name',
          message: `Property "name" must be a valid DNS name format. Got: "${props.name}"`,
          code: 'INVALID_PATTERN',
          fix: 'Use a valid DNS name format (e.g., "contoso.com", "subdomain.example.com"). Only alphanumeric characters, hyphens, and dots are allowed.',
        });
      }
    }
  }

  // Validate required property: properties
  if (props.properties === undefined || props.properties === null) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with domain service configuration',
    });
  } else {
    // Validate properties.domainName if present
    if (props.properties.domainName !== undefined) {
      if (typeof props.properties.domainName !== 'string') {
        errors.push({
          path: 'properties.domainName',
          message: 'Property "properties.domainName" must be a string',
          code: 'INVALID_TYPE',
          fix: 'Ensure "domainName" is a string value',
        });
      } else if (!DOMAIN_NAME_PATTERN.test(props.properties.domainName)) {
        errors.push({
          path: 'properties.domainName',
          message: `Property "properties.domainName" must be a valid DNS name. Got: "${props.properties.domainName}"`,
          code: 'INVALID_PATTERN',
          fix: 'Use a valid DNS name format (e.g., "contoso.com")',
        });
      }
    }

    // Validate properties.sku if present
    if (props.properties.sku !== undefined) {
      const validSkus = ['Standard', 'Enterprise', 'Premium'];
      if (!validSkus.includes(props.properties.sku)) {
        errors.push({
          path: 'properties.sku',
          message: `Property "properties.sku" must be one of: ${validSkus.join(', ')}. Got: "${props.properties.sku}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose a valid SKU: ${validSkus.join(', ')}`,
        });
      }
    }

    // Validate properties.domainConfigurationType if present
    if (props.properties.domainConfigurationType !== undefined) {
      const validTypes = ['FullySynced', 'ResourceTrusting'];
      if (!validTypes.includes(props.properties.domainConfigurationType)) {
        errors.push({
          path: 'properties.domainConfigurationType',
          message: `Property "properties.domainConfigurationType" must be one of: ${validTypes.join(', ')}. Got: "${props.properties.domainConfigurationType}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose a valid configuration type: ${validTypes.join(', ')}`,
        });
      }
    }

    // Validate properties.filteredSync if present
    if (props.properties.filteredSync !== undefined) {
      const validValues = ['Enabled', 'Disabled'];
      if (!validValues.includes(props.properties.filteredSync)) {
        errors.push({
          path: 'properties.filteredSync',
          message: `Property "properties.filteredSync" must be one of: ${validValues.join(', ')}. Got: "${props.properties.filteredSync}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose either "Enabled" or "Disabled"`,
        });
      }
    }

    // Validate properties.syncScope if present
    if (props.properties.syncScope !== undefined) {
      const validValues = ['All', 'CloudOnly'];
      if (!validValues.includes(props.properties.syncScope)) {
        errors.push({
          path: 'properties.syncScope',
          message: `Property "properties.syncScope" must be one of: ${validValues.join(', ')}. Got: "${props.properties.syncScope}"`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Choose either "All" (sync all users) or "CloudOnly" (sync only cloud users)`,
        });
      }
    }

    // Validate properties.replicaSets if present
    if (props.properties.replicaSets !== undefined) {
      if (!Array.isArray(props.properties.replicaSets)) {
        errors.push({
          path: 'properties.replicaSets',
          message: 'Property "properties.replicaSets" must be an array',
          code: 'INVALID_TYPE',
          fix: 'Provide an array of replica set configurations',
        });
      } else {
        // At least one replica set is required
        if (props.properties.replicaSets.length === 0) {
          errors.push({
            path: 'properties.replicaSets',
            message: 'Property "properties.replicaSets" must contain at least one replica set',
            code: 'ARRAY_MIN_LENGTH',
            fix: 'Add at least one replica set with location and subnetId',
          });
        }

        // Validate each replica set
        props.properties.replicaSets.forEach((replicaSet: any, index: number) => {
          const basePath = `properties.replicaSets[${index}]`;

          // Validate subnetId format if present
          if (replicaSet.subnetId !== undefined) {
            if (typeof replicaSet.subnetId !== 'string') {
              errors.push({
                path: `${basePath}.subnetId`,
                message: `Property "${basePath}.subnetId" must be a string`,
                code: 'INVALID_TYPE',
                fix: 'Provide a valid Azure subnet resource ID',
              });
            } else if (!SUBNET_ID_PATTERN.test(replicaSet.subnetId)) {
              errors.push({
                path: `${basePath}.subnetId`,
                message: `Property "${basePath}.subnetId" must be a valid Azure subnet resource ID`,
                code: 'INVALID_PATTERN',
                fix: 'Use format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}',
              });
            }
          }

          // Validate location if present
          if (replicaSet.location !== undefined && typeof replicaSet.location !== 'string') {
            errors.push({
              path: `${basePath}.location`,
              message: `Property "${basePath}.location" must be a string`,
              code: 'INVALID_TYPE',
              fix: 'Provide a valid Azure region (e.g., "westus2", "eastus")',
            });
          }
        });
      }
    }

    // Validate properties.domainSecuritySettings if present
    if (props.properties.domainSecuritySettings !== undefined) {
      const securitySettings = props.properties.domainSecuritySettings;
      const validSecurityValues = ['Enabled', 'Disabled'];
      const securityFields = [
        'channelBinding',
        'kerberosArmoring',
        'kerberosRc4Encryption',
        'ldapSigning',
        'ntlmV1',
        'syncKerberosPasswords',
        'syncNtlmPasswords',
        'syncOnPremPasswords',
        'tlsV1',
      ];

      securityFields.forEach((field) => {
        if (
          securitySettings[field] !== undefined &&
          !validSecurityValues.includes(securitySettings[field])
        ) {
          errors.push({
            path: `properties.domainSecuritySettings.${field}`,
            message: `Property "properties.domainSecuritySettings.${field}" must be one of: ${validSecurityValues.join(', ')}. Got: "${securitySettings[field]}"`,
            code: 'INVALID_ENUM_VALUE',
            fix: `Choose either "Enabled" or "Disabled"`,
          });
        }
      });
    }

    // Validate properties.notificationSettings if present
    if (props.properties.notificationSettings !== undefined) {
      const notificationSettings = props.properties.notificationSettings;

      // Validate notification flags
      const validNotificationValues = ['Enabled', 'Disabled'];
      ['notifyDcAdmins', 'notifyGlobalAdmins'].forEach((field) => {
        if (
          notificationSettings[field] !== undefined &&
          !validNotificationValues.includes(notificationSettings[field])
        ) {
          errors.push({
            path: `properties.notificationSettings.${field}`,
            message: `Property "properties.notificationSettings.${field}" must be one of: ${validNotificationValues.join(', ')}. Got: "${notificationSettings[field]}"`,
            code: 'INVALID_ENUM_VALUE',
            fix: `Choose either "Enabled" or "Disabled"`,
          });
        }
      });

      // Validate additionalRecipients email addresses
      if (notificationSettings.additionalRecipients !== undefined) {
        if (!Array.isArray(notificationSettings.additionalRecipients)) {
          errors.push({
            path: 'properties.notificationSettings.additionalRecipients',
            message: 'Property "properties.notificationSettings.additionalRecipients" must be an array',
            code: 'INVALID_TYPE',
            fix: 'Provide an array of email addresses',
          });
        } else {
          notificationSettings.additionalRecipients.forEach((email: any, index: number) => {
            if (typeof email !== 'string') {
              errors.push({
                path: `properties.notificationSettings.additionalRecipients[${index}]`,
                message: `Email address at index ${index} must be a string`,
                code: 'INVALID_TYPE',
                fix: 'Provide a valid email address string',
              });
            } else if (!EMAIL_PATTERN.test(email)) {
              errors.push({
                path: `properties.notificationSettings.additionalRecipients[${index}]`,
                message: `Invalid email address format: "${email}"`,
                code: 'INVALID_PATTERN',
                fix: 'Provide a valid email address (e.g., "admin@contoso.com")',
              });
            }
          });
        }
      }
    }

    // Validate properties.ldapsSettings if present
    if (props.properties.ldapsSettings !== undefined) {
      const ldapsSettings = props.properties.ldapsSettings;
      const validLdapsValues = ['Enabled', 'Disabled'];

      ['ldaps', 'externalAccess'].forEach((field) => {
        if (ldapsSettings[field] !== undefined && !validLdapsValues.includes(ldapsSettings[field])) {
          errors.push({
            path: `properties.ldapsSettings.${field}`,
            message: `Property "properties.ldapsSettings.${field}" must be one of: ${validLdapsValues.join(', ')}. Got: "${ldapsSettings[field]}"`,
            code: 'INVALID_ENUM_VALUE',
            fix: `Choose either "Enabled" or "Disabled"`,
          });
        }
      });
    }
  }

  // Validate location if present
  if (props.location !== undefined && typeof props.location !== 'string') {
    errors.push({
      path: 'location',
      message: 'Property "location" must be a string',
      code: 'INVALID_TYPE',
      fix: 'Provide a valid Azure region (e.g., "westus2", "eastus")',
    });
  }

  // Validate tags if present
  if (props.tags !== undefined) {
    if (typeof props.tags !== 'object' || Array.isArray(props.tags)) {
      errors.push({
        path: 'tags',
        message: 'Property "tags" must be an object with string key-value pairs',
        code: 'INVALID_TYPE',
        fix: 'Provide an object with string keys and values, e.g., { environment: "production" }',
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate Microsoft.AAD/domainServices/ouContainer properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 *
 * @example
 * ```typescript
 * const result = validateDomainServicesOuContainer({
 *   name: 'AADDC Computers',
 *   properties: {
 *     accounts: [{
 *       accountName: 'admin',
 *       spn: 'HTTP/webapp.contoso.com'
 *     }]
 *   }
 * });
 * ```
 */
export function validateDomainServicesOuContainer(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required property: name
  if (props.name === undefined || props.name === null) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your OU container definition',
    });
  } else if (typeof props.name !== 'string') {
    errors.push({
      path: 'name',
      message: 'Property "name" must be a string',
      code: 'INVALID_TYPE',
      fix: 'Ensure "name" is a string value (e.g., "AADDC Computers")',
    });
  }

  // Validate properties.accounts if present
  if (props.properties?.accounts !== undefined) {
    if (!Array.isArray(props.properties.accounts)) {
      errors.push({
        path: 'properties.accounts',
        message: 'Property "properties.accounts" must be an array',
        code: 'INVALID_TYPE',
        fix: 'Provide an array of account objects',
      });
    } else {
      props.properties.accounts.forEach((account: any, index: number) => {
        const basePath = `properties.accounts[${index}]`;

        if (account.accountName !== undefined && typeof account.accountName !== 'string') {
          errors.push({
            path: `${basePath}.accountName`,
            message: `Property "${basePath}.accountName" must be a string`,
            code: 'INVALID_TYPE',
            fix: 'Provide a valid account name string',
          });
        }

        if (account.spn !== undefined && typeof account.spn !== 'string') {
          errors.push({
            path: `${basePath}.spn`,
            message: `Property "${basePath}.spn" must be a string`,
            code: 'INVALID_TYPE',
            fix: 'Provide a valid Service Principal Name (SPN) string',
          });
        }
      });
    }
  }

  // Validate location if present
  if (props.location !== undefined && typeof props.location !== 'string') {
    errors.push({
      path: 'location',
      message: 'Property "location" must be a string',
      code: 'INVALID_TYPE',
      fix: 'Provide a valid Azure region (e.g., "westus2", "eastus")',
    });
  }

  // Validate tags if present
  if (props.tags !== undefined) {
    if (typeof props.tags !== 'object' || Array.isArray(props.tags)) {
      errors.push({
        path: 'tags',
        message: 'Property "tags" must be an object with string key-value pairs',
        code: 'INVALID_TYPE',
        fix: 'Provide an object with string keys and values',
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
