/**
 * Runtime validators for Microsoft.Authorization resources.
 *
 * **API Version**: 2022-04-01
 * **Generated**: 2025-10-13T00:00:00.000Z
 *
 * @remarks
 * This file is auto-generated. Do not edit manually.
 * Generated by Felix (Schema & Validation Engineer)
 *
 * @packageDocumentation
 */

/**
 * Validation error.
 */
export interface ValidationError {
  readonly path: string;
  readonly message: string;
  readonly code: string;
  readonly fix?: string;
}

/**
 * Validation result.
 */
export interface ValidationResult {
  readonly valid: boolean;
  readonly errors: ValidationError[];
}

/**
 * Validate GUID format.
 *
 * @param value - Value to validate
 * @returns true if valid GUID format
 */
function isValidGuid(value: string): boolean {
  const guidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  return guidPattern.test(value);
}

/**
 * Validate Azure resource ID format.
 *
 * @param value - Value to validate
 * @returns true if valid resource ID format
 */
function isValidResourceId(value: string): boolean {
  // Basic validation - starts with /subscriptions/ or /providers/
  return value.startsWith('/subscriptions/') || value.startsWith('/providers/');
}

/**
 * Validate Microsoft.Authorization/roleAssignments properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validateRoleAssignments(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required property: name
  if (props.name === undefined || props.name === null) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property with a valid GUID value',
    });
  } else if (typeof props.name === 'string' && !isValidGuid(props.name)) {
    errors.push({
      path: 'name',
      message: 'Property "name" must be a valid GUID',
      code: 'INVALID_GUID_FORMAT',
      fix: 'Use a valid GUID format (e.g., "00000000-0000-0000-0000-000000000000")',
    });
  }

  // Validate required property: properties
  if (props.properties === undefined || props.properties === null) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with required fields',
    });
  } else {
    const propsObj = props.properties;

    // Validate required: roleDefinitionId
    if (propsObj.roleDefinitionId === undefined || propsObj.roleDefinitionId === null) {
      errors.push({
        path: 'properties.roleDefinitionId',
        message: 'Required property "roleDefinitionId" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add "roleDefinitionId" with a valid role definition resource ID',
      });
    } else if (typeof propsObj.roleDefinitionId === 'string' && !isValidResourceId(propsObj.roleDefinitionId)) {
      errors.push({
        path: 'properties.roleDefinitionId',
        message: 'Property "roleDefinitionId" must be a valid Azure resource ID',
        code: 'INVALID_RESOURCE_ID',
        fix: 'Use a valid role definition ID format (e.g., "/subscriptions/{id}/providers/Microsoft.Authorization/roleDefinitions/{id}")',
      });
    }

    // Validate required: principalId
    if (propsObj.principalId === undefined || propsObj.principalId === null) {
      errors.push({
        path: 'properties.principalId',
        message: 'Required property "principalId" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add "principalId" with a valid Azure AD object ID (GUID)',
      });
    } else if (typeof propsObj.principalId === 'string' && !isValidGuid(propsObj.principalId)) {
      errors.push({
        path: 'properties.principalId',
        message: 'Property "principalId" must be a valid GUID',
        code: 'INVALID_GUID_FORMAT',
        fix: 'Use a valid GUID format for the principal ID',
      });
    }

    // Validate principalType enum
    if (propsObj.principalType !== undefined && propsObj.principalType !== null) {
      const validPrincipalTypes = ['User', 'Group', 'ServicePrincipal', 'ForeignGroup'];
      if (!validPrincipalTypes.includes(propsObj.principalType) && typeof propsObj.principalType !== 'object') {
        errors.push({
          path: 'properties.principalType',
          message: `Property "principalType" must be one of: ${validPrincipalTypes.join(', ')}`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Use one of the valid principal types: ${validPrincipalTypes.join(', ')}`,
        });
      }
    }

    // Validate description length
    if (propsObj.description !== undefined && propsObj.description !== null) {
      if (typeof propsObj.description === 'string' && propsObj.description.length > 512) {
        errors.push({
          path: 'properties.description',
          message: 'Property "description" must not exceed 512 characters',
          code: 'STRING_TOO_LONG',
          fix: 'Shorten the description to 512 characters or less',
        });
      }
    }

    // Validate condition and conditionVersion
    if (propsObj.condition !== undefined && propsObj.condition !== null) {
      if (propsObj.conditionVersion === undefined || propsObj.conditionVersion === null) {
        errors.push({
          path: 'properties.conditionVersion',
          message: 'Property "conditionVersion" is required when "condition" is specified',
          code: 'REQUIRED_PROPERTY_MISSING',
          fix: 'Add "conditionVersion" property (e.g., "2.0")',
        });
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate Microsoft.Authorization/policyAssignments properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validatePolicyAssignments(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required property: name
  if (props.name === undefined || props.name === null) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your policy assignment',
    });
  } else if (typeof props.name === 'string') {
    // Validate name length (1-128 for most scopes)
    if (props.name.length < 1) {
      errors.push({
        path: 'name',
        message: 'Property "name" must be at least 1 character',
        code: 'STRING_TOO_SHORT',
        fix: 'Provide a non-empty name',
      });
    }
    if (props.name.length > 260) {
      errors.push({
        path: 'name',
        message: 'Property "name" must not exceed 260 characters',
        code: 'STRING_TOO_LONG',
        fix: 'Shorten the name to 260 characters or less',
      });
    }

    // Validate name pattern (no special characters)
    if (/<|>|\*|%|&|:|\\|\?|\.|\\+|\//g.test(props.name)) {
      errors.push({
        path: 'name',
        message: 'Property "name" contains invalid characters (<>*%&:\\?.+/)',
        code: 'INVALID_NAME_PATTERN',
        fix: 'Remove special characters from the name',
      });
    }
  }

  // Validate required property: properties
  if (props.properties === undefined || props.properties === null) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with required fields',
    });
  } else {
    const propsObj = props.properties;

    // Validate required: policyDefinitionId
    if (propsObj.policyDefinitionId === undefined || propsObj.policyDefinitionId === null) {
      errors.push({
        path: 'properties.policyDefinitionId',
        message: 'Required property "policyDefinitionId" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add "policyDefinitionId" with a valid policy definition resource ID',
      });
    } else if (typeof propsObj.policyDefinitionId === 'string' && !isValidResourceId(propsObj.policyDefinitionId)) {
      errors.push({
        path: 'properties.policyDefinitionId',
        message: 'Property "policyDefinitionId" must be a valid Azure resource ID',
        code: 'INVALID_RESOURCE_ID',
        fix: 'Use a valid policy definition ID format',
      });
    }

    // Validate displayName length
    if (propsObj.displayName !== undefined && propsObj.displayName !== null) {
      if (typeof propsObj.displayName === 'string' && propsObj.displayName.length > 128) {
        errors.push({
          path: 'properties.displayName',
          message: 'Property "displayName" must not exceed 128 characters',
          code: 'STRING_TOO_LONG',
          fix: 'Shorten the display name to 128 characters or less',
        });
      }
    }

    // Validate description length
    if (propsObj.description !== undefined && propsObj.description !== null) {
      if (typeof propsObj.description === 'string' && propsObj.description.length > 512) {
        errors.push({
          path: 'properties.description',
          message: 'Property "description" must not exceed 512 characters',
          code: 'STRING_TOO_LONG',
          fix: 'Shorten the description to 512 characters or less',
        });
      }
    }

    // Validate enforcementMode enum
    if (propsObj.enforcementMode !== undefined && propsObj.enforcementMode !== null) {
      const validModes = ['Default', 'DoNotEnforce'];
      if (!validModes.includes(propsObj.enforcementMode) && typeof propsObj.enforcementMode !== 'object') {
        errors.push({
          path: 'properties.enforcementMode',
          message: `Property "enforcementMode" must be one of: ${validModes.join(', ')}`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Use one of the valid enforcement modes: ${validModes.join(', ')}`,
        });
      }
    }

    // Validate identity type
    if (propsObj.identity !== undefined && propsObj.identity !== null) {
      const validIdentityTypes = ['SystemAssigned', 'UserAssigned', 'None'];
      if (propsObj.identity.type && !validIdentityTypes.includes(propsObj.identity.type) && typeof propsObj.identity.type !== 'object') {
        errors.push({
          path: 'properties.identity.type',
          message: `Property "identity.type" must be one of: ${validIdentityTypes.join(', ')}`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Use one of the valid identity types: ${validIdentityTypes.join(', ')}`,
        });
      }
    }
  }

  // Validate location when identity is specified
  if (props.identity !== undefined && props.identity !== null) {
    if (props.location === undefined || props.location === null) {
      errors.push({
        path: 'location',
        message: 'Property "location" is required when identity is specified',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add a valid Azure region for the location property',
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate Microsoft.Authorization/locks properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validateLocks(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required property: name
  if (props.name === undefined || props.name === null) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property to your lock',
    });
  } else if (typeof props.name === 'string') {
    // Validate name length
    if (props.name.length < 1) {
      errors.push({
        path: 'name',
        message: 'Property "name" must be at least 1 character',
        code: 'STRING_TOO_SHORT',
        fix: 'Provide a non-empty name',
      });
    }
    if (props.name.length > 90) {
      errors.push({
        path: 'name',
        message: 'Property "name" must not exceed 90 characters',
        code: 'STRING_TOO_LONG',
        fix: 'Shorten the name to 90 characters or less',
      });
    }

    // Validate name pattern (alphanumeric, periods, underscores, hyphens, parentheses)
    if (!/^[a-zA-Z0-9._()-]+$/.test(props.name)) {
      errors.push({
        path: 'name',
        message: 'Property "name" can only contain alphanumeric characters, periods, underscores, hyphens, and parentheses',
        code: 'INVALID_NAME_PATTERN',
        fix: 'Use only allowed characters in the lock name',
      });
    }
  }

  // Validate required property: properties
  if (props.properties === undefined || props.properties === null) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with the "level" field',
    });
  } else {
    const propsObj = props.properties;

    // Validate required: level
    if (propsObj.level === undefined || propsObj.level === null) {
      errors.push({
        path: 'properties.level',
        message: 'Required property "level" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add "level" property with either "CanNotDelete" or "ReadOnly"',
      });
    } else {
      const validLevels = ['CanNotDelete', 'ReadOnly'];
      if (!validLevels.includes(propsObj.level) && typeof propsObj.level !== 'object') {
        errors.push({
          path: 'properties.level',
          message: `Property "level" must be one of: ${validLevels.join(', ')}`,
          code: 'INVALID_ENUM_VALUE',
          fix: `Use one of the valid lock levels: ${validLevels.join(', ')}`,
        });
      }
    }

    // Validate notes length
    if (propsObj.notes !== undefined && propsObj.notes !== null) {
      if (typeof propsObj.notes === 'string' && propsObj.notes.length > 512) {
        errors.push({
          path: 'properties.notes',
          message: 'Property "notes" must not exceed 512 characters',
          code: 'STRING_TOO_LONG',
          fix: 'Shorten the notes to 512 characters or less',
        });
      }
    }

    // Validate owners
    if (propsObj.owners !== undefined && propsObj.owners !== null) {
      if (Array.isArray(propsObj.owners)) {
        propsObj.owners.forEach((owner: any, index: number) => {
          if (owner.applicationId && typeof owner.applicationId === 'string' && !isValidGuid(owner.applicationId)) {
            errors.push({
              path: `properties.owners[${index}].applicationId`,
              message: 'Property "applicationId" must be a valid GUID',
              code: 'INVALID_GUID_FORMAT',
              fix: 'Use a valid GUID format for the application ID',
            });
          }
        });
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate Microsoft.Authorization/roleDefinitions properties.
 *
 * @param props - Resource properties to validate
 * @returns Validation result
 */
export function validateRoleDefinitions(props: any): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate required property: name
  if (props.name === undefined || props.name === null) {
    errors.push({
      path: 'name',
      message: 'Required property "name" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "name" property with a valid GUID value',
    });
  } else if (typeof props.name === 'string' && !isValidGuid(props.name)) {
    errors.push({
      path: 'name',
      message: 'Property "name" must be a valid GUID',
      code: 'INVALID_GUID_FORMAT',
      fix: 'Use a valid GUID format for the role definition ID',
    });
  }

  // Validate required property: properties
  if (props.properties === undefined || props.properties === null) {
    errors.push({
      path: 'properties',
      message: 'Required property "properties" is missing',
      code: 'REQUIRED_PROPERTY_MISSING',
      fix: 'Add the "properties" object with required fields',
    });
  } else {
    const propsObj = props.properties;

    // Validate required: roleName
    if (propsObj.roleName === undefined || propsObj.roleName === null) {
      errors.push({
        path: 'properties.roleName',
        message: 'Required property "roleName" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add "roleName" property with the custom role name',
      });
    } else if (typeof propsObj.roleName === 'string') {
      if (propsObj.roleName.length > 512) {
        errors.push({
          path: 'properties.roleName',
          message: 'Property "roleName" must not exceed 512 characters',
          code: 'STRING_TOO_LONG',
          fix: 'Shorten the role name to 512 characters or less',
        });
      }
    }

    // Validate description length
    if (propsObj.description !== undefined && propsObj.description !== null) {
      if (typeof propsObj.description === 'string' && propsObj.description.length > 1024) {
        errors.push({
          path: 'properties.description',
          message: 'Property "description" must not exceed 1024 characters',
          code: 'STRING_TOO_LONG',
          fix: 'Shorten the description to 1024 characters or less',
        });
      }
    }

    // Validate required: assignableScopes
    if (propsObj.assignableScopes === undefined || propsObj.assignableScopes === null) {
      errors.push({
        path: 'properties.assignableScopes',
        message: 'Required property "assignableScopes" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add "assignableScopes" array with at least one valid scope',
      });
    } else if (Array.isArray(propsObj.assignableScopes)) {
      if (propsObj.assignableScopes.length === 0) {
        errors.push({
          path: 'properties.assignableScopes',
          message: 'Property "assignableScopes" must contain at least one scope',
          code: 'ARRAY_TOO_SHORT',
          fix: 'Add at least one assignable scope to the array',
        });
      }
      if (propsObj.assignableScopes.length > 2000) {
        errors.push({
          path: 'properties.assignableScopes',
          message: 'Property "assignableScopes" must not exceed 2000 scopes',
          code: 'ARRAY_TOO_LONG',
          fix: 'Reduce the number of assignable scopes to 2000 or less',
        });
      }
    }

    // Validate required: permissions
    if (propsObj.permissions === undefined || propsObj.permissions === null) {
      errors.push({
        path: 'properties.permissions',
        message: 'Required property "permissions" is missing',
        code: 'REQUIRED_PROPERTY_MISSING',
        fix: 'Add "permissions" array with at least one permission object',
      });
    } else if (Array.isArray(propsObj.permissions) && propsObj.permissions.length === 0) {
      errors.push({
        path: 'properties.permissions',
        message: 'Property "permissions" must contain at least one permission',
        code: 'ARRAY_TOO_SHORT',
        fix: 'Add at least one permission to the array',
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
