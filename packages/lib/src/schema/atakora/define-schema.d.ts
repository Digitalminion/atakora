/**
 * Main schema definition function and validation.
 *
 * @remarks
 * Provides the `defineSchema` function for creating data model definitions
 * with full type inference and validation.
 *
 * @packageDocumentation
 */
import type { z } from 'zod';
import type { SchemaDefinition } from './schema-types';
/**
 * Define a data schema with full type inference.
 *
 * @param name - Entity name
 * @param definition - Schema definition
 * @returns Validated schema definition
 *
 * @example
 * ```typescript
 * import { defineSchema, Fields, allow, hasMany, belongsTo } from '@atakora/lib/schema/atakora';
 * import { z } from 'zod';
 *
 * const UserSchema = defineSchema('User', {
 *   fields: z.object({
 *     id: Fields.id(),
 *     email: Fields.email().unique(),
 *     name: z.string().min(1).max(100),
 *     role: z.enum(['admin', 'user', 'guest']).default('user'),
 *     createdAt: Fields.createdAt(),
 *     updatedAt: Fields.updatedAt()
 *   }),
 *
 *   authorization: {
 *     create: allow.authenticated(),
 *     read: allow.public(),
 *     update: allow.owner('id').or(allow.role('admin')),
 *     delete: allow.role('admin'),
 *     fields: {
 *       email: allow.owner('id').or(allow.role('admin'))
 *     }
 *   },
 *
 *   indexes: {
 *     byEmail: { fields: ['email'], unique: true },
 *     byRole: { fields: ['role', 'createdAt'] }
 *   },
 *
 *   relationships: {
 *     posts: hasMany('Post', 'authorId'),
 *     profile: hasOne('Profile', 'userId')
 *   },
 *
 *   hooks: {
 *     beforeCreate: async (data, context) => {
 *       // Normalize email
 *       data.email = data.email.toLowerCase();
 *       return data;
 *     },
 *     afterCreate: async (data, context) => {
 *       // Send welcome email
 *       console.log(`User created: ${data.email}`);
 *     }
 *   }
 * });
 *
 * // Type inference works automatically
 * type User = InferSchemaType<typeof UserSchema>;
 * ```
 */
export declare function defineSchema<TFields extends z.ZodRawShape>(name: string, definition: Omit<SchemaDefinition<TFields>, 'name'>): SchemaDefinition<TFields>;
/**
 * Validate a schema definition.
 *
 * @param schema - Schema to validate
 * @returns Validation result
 */
export declare function validateSchema(schema: SchemaDefinition<any>): {
    valid: boolean;
    errors: string[];
};
/**
 * Get the primary key field from a schema.
 *
 * @param schema - Schema definition
 * @returns Primary key field name or undefined
 */
export declare function getPrimaryKeyField(schema: SchemaDefinition<any>): string | undefined;
/**
 * Get all unique fields from a schema.
 *
 * @param schema - Schema definition
 * @returns Array of unique field names
 */
export declare function getUniqueFields(schema: SchemaDefinition<any>): string[];
/**
 * Get all indexed fields from a schema.
 *
 * @param schema - Schema definition
 * @returns Array of indexed field names
 */
export declare function getIndexedFields(schema: SchemaDefinition<any>): string[];
/**
 * Get all auto-generated fields from a schema.
 *
 * @param schema - Schema definition
 * @returns Map of field names to generation type
 */
export declare function getAutoGeneratedFields(schema: SchemaDefinition<any>): Map<string, 'uuid' | 'cuid' | 'increment' | 'timestamp'>;
/**
 * Get all auto-updated fields from a schema.
 *
 * @param schema - Schema definition
 * @returns Array of auto-updated field names
 */
export declare function getAutoUpdatedFields(schema: SchemaDefinition<any>): string[];
/**
 * Extract field metadata from a schema.
 *
 * @param schema - Schema definition
 * @returns Map of field names to metadata
 */
export declare function extractFieldMetadata(schema: SchemaDefinition<any>): Map<string, any>;
/**
 * Check if a schema has a specific relationship.
 *
 * @param schema - Schema definition
 * @param relationshipName - Relationship name
 * @returns True if relationship exists
 */
export declare function hasRelationship(schema: SchemaDefinition<any>, relationshipName: string): boolean;
/**
 * Get relationship by name.
 *
 * @param schema - Schema definition
 * @param relationshipName - Relationship name
 * @returns Relationship definition or undefined
 */
export declare function getRelationship(schema: SchemaDefinition<any>, relationshipName: string): any;
/**
 * Get all relationships of a specific type.
 *
 * @param schema - Schema definition
 * @param type - Relationship type
 * @returns Array of relationship names
 */
export declare function getRelationshipsByType(schema: SchemaDefinition<any>, type: 'hasOne' | 'hasMany' | 'belongsTo' | 'manyToMany' | 'polymorphic'): string[];
/**
 * Schema registry for managing multiple schemas.
 */
export declare class SchemaRegistry {
    private schemas;
    /**
     * Register a schema.
     */
    register(schema: SchemaDefinition<any>): void;
    /**
     * Get a schema by name.
     */
    get(name: string): SchemaDefinition<any> | undefined;
    /**
     * Check if a schema exists.
     */
    has(name: string): boolean;
    /**
     * Get all registered schemas.
     */
    all(): SchemaDefinition<any>[];
    /**
     * Get all schema names.
     */
    names(): string[];
    /**
     * Clear all schemas.
     */
    clear(): void;
    /**
     * Validate all relationships across schemas.
     */
    validateRelationships(): {
        valid: boolean;
        errors: string[];
    };
}
/**
 * Global schema registry instance.
 */
export declare const globalSchemaRegistry: SchemaRegistry;
//# sourceMappingURL=define-schema.d.ts.map