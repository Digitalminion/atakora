"use strict";
/**
 * Main schema definition function and validation.
 *
 * @remarks
 * Provides the `defineSchema` function for creating data model definitions
 * with full type inference and validation.
 *
 * @packageDocumentation
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.globalSchemaRegistry = exports.SchemaRegistry = void 0;
exports.defineSchema = defineSchema;
exports.validateSchema = validateSchema;
exports.getPrimaryKeyField = getPrimaryKeyField;
exports.getUniqueFields = getUniqueFields;
exports.getIndexedFields = getIndexedFields;
exports.getAutoGeneratedFields = getAutoGeneratedFields;
exports.getAutoUpdatedFields = getAutoUpdatedFields;
exports.extractFieldMetadata = extractFieldMetadata;
exports.hasRelationship = hasRelationship;
exports.getRelationship = getRelationship;
exports.getRelationshipsByType = getRelationshipsByType;
var authorization_1 = require("./authorization");
var relationships_1 = require("./relationships");
/**
 * Define a data schema with full type inference.
 *
 * @param name - Entity name
 * @param definition - Schema definition
 * @returns Validated schema definition
 *
 * @example
 * ```typescript
 * import { defineSchema, Fields, allow, hasMany, belongsTo } from '@atakora/lib/schema/atakora';
 * import { z } from 'zod';
 *
 * const UserSchema = defineSchema('User', {
 *   fields: z.object({
 *     id: Fields.id(),
 *     email: Fields.email().unique(),
 *     name: z.string().min(1).max(100),
 *     role: z.enum(['admin', 'user', 'guest']).default('user'),
 *     createdAt: Fields.createdAt(),
 *     updatedAt: Fields.updatedAt()
 *   }),
 *
 *   authorization: {
 *     create: allow.authenticated(),
 *     read: allow.public(),
 *     update: allow.owner('id').or(allow.role('admin')),
 *     delete: allow.role('admin'),
 *     fields: {
 *       email: allow.owner('id').or(allow.role('admin'))
 *     }
 *   },
 *
 *   indexes: {
 *     byEmail: { fields: ['email'], unique: true },
 *     byRole: { fields: ['role', 'createdAt'] }
 *   },
 *
 *   relationships: {
 *     posts: hasMany('Post', 'authorId'),
 *     profile: hasOne('Profile', 'userId')
 *   },
 *
 *   hooks: {
 *     beforeCreate: async (data, context) => {
 *       // Normalize email
 *       data.email = data.email.toLowerCase();
 *       return data;
 *     },
 *     afterCreate: async (data, context) => {
 *       // Send welcome email
 *       console.log(`User created: ${data.email}`);
 *     }
 *   }
 * });
 *
 * // Type inference works automatically
 * type User = InferSchemaType<typeof UserSchema>;
 * ```
 */
function defineSchema(name, definition) {
    var schema = __assign({ name: name }, definition);
    // Validate the schema
    var validation = validateSchema(schema);
    if (!validation.valid) {
        throw new Error("Invalid schema definition for '".concat(name, "':\n").concat(validation.errors.join('\n')));
    }
    return schema;
}
/**
 * Validate a schema definition.
 *
 * @param schema - Schema to validate
 * @returns Validation result
 */
function validateSchema(schema) {
    var errors = [];
    // Validate name
    if (!schema.name || schema.name.trim() === '') {
        errors.push('Schema name cannot be empty');
    }
    if (!/^[A-Z][a-zA-Z0-9]*$/.test(schema.name)) {
        errors.push("Schema name '".concat(schema.name, "' must start with uppercase letter and contain only alphanumeric characters"));
    }
    // Validate fields
    if (!schema.fields) {
        errors.push('Schema must have a fields definition');
    }
    // Validate authorization rules if present
    if (schema.authorization) {
        var authValidation = (0, authorization_1.validateAuthorizationRules)(schema.authorization);
        if (!authValidation.valid) {
            errors.push.apply(errors, authValidation.errors);
        }
    }
    // Validate relationships if present
    if (schema.relationships) {
        for (var _i = 0, _a = Object.entries(schema.relationships); _i < _a.length; _i++) {
            var _b = _a[_i], name_1 = _b[0], rel = _b[1];
            var relValidation = (0, relationships_1.validateRelationship)(name_1, rel);
            if (!relValidation.valid) {
                errors.push.apply(errors, relValidation.errors);
            }
        }
    }
    // Validate indexes if present
    if (schema.indexes) {
        for (var _c = 0, _d = Object.entries(schema.indexes); _c < _d.length; _c++) {
            var _e = _d[_c], name_2 = _e[0], index = _e[1];
            if (!index.fields || index.fields.length === 0) {
                errors.push("Index '".concat(name_2, "' must have at least one field"));
            }
        }
    }
    // Validate computed fields if present
    if (schema.computed) {
        for (var _f = 0, _g = Object.entries(schema.computed); _f < _g.length; _f++) {
            var _h = _g[_f], name_3 = _h[0], computed = _h[1];
            if (!computed.compute) {
                errors.push("Computed field '".concat(name_3, "' must have a compute function"));
            }
            if (!computed.type) {
                errors.push("Computed field '".concat(name_3, "' must have a type"));
            }
        }
    }
    return {
        valid: errors.length === 0,
        errors: errors,
    };
}
/**
 * Get the primary key field from a schema.
 *
 * @param schema - Schema definition
 * @returns Primary key field name or undefined
 */
function getPrimaryKeyField(schema) {
    var _a;
    var shape = schema.fields.shape;
    for (var _i = 0, _b = Object.entries(shape); _i < _b.length; _i++) {
        var _c = _b[_i], fieldName = _c[0], fieldSchema = _c[1];
        if ((_a = fieldSchema._metadata) === null || _a === void 0 ? void 0 : _a.primaryKey) {
            return fieldName;
        }
    }
    // Default to 'id' if no explicit primary key
    if ('id' in shape) {
        return 'id';
    }
    return undefined;
}
/**
 * Get all unique fields from a schema.
 *
 * @param schema - Schema definition
 * @returns Array of unique field names
 */
function getUniqueFields(schema) {
    var _a;
    var shape = schema.fields.shape;
    var uniqueFields = [];
    for (var _i = 0, _b = Object.entries(shape); _i < _b.length; _i++) {
        var _c = _b[_i], fieldName = _c[0], fieldSchema = _c[1];
        if ((_a = fieldSchema._metadata) === null || _a === void 0 ? void 0 : _a.unique) {
            uniqueFields.push(fieldName);
        }
    }
    return uniqueFields;
}
/**
 * Get all indexed fields from a schema.
 *
 * @param schema - Schema definition
 * @returns Array of indexed field names
 */
function getIndexedFields(schema) {
    var _a;
    var shape = schema.fields.shape;
    var indexedFields = [];
    for (var _i = 0, _b = Object.entries(shape); _i < _b.length; _i++) {
        var _c = _b[_i], fieldName = _c[0], fieldSchema = _c[1];
        if ((_a = fieldSchema._metadata) === null || _a === void 0 ? void 0 : _a.indexed) {
            indexedFields.push(fieldName);
        }
    }
    return indexedFields;
}
/**
 * Get all auto-generated fields from a schema.
 *
 * @param schema - Schema definition
 * @returns Map of field names to generation type
 */
function getAutoGeneratedFields(schema) {
    var shape = schema.fields.shape;
    var autoFields = new Map();
    for (var _i = 0, _a = Object.entries(shape); _i < _a.length; _i++) {
        var _b = _a[_i], fieldName = _b[0], fieldSchema = _b[1];
        var metadata = fieldSchema._metadata;
        if (metadata === null || metadata === void 0 ? void 0 : metadata.autoGenerate) {
            autoFields.set(fieldName, metadata.autoGenerate);
        }
    }
    return autoFields;
}
/**
 * Get all auto-updated fields from a schema.
 *
 * @param schema - Schema definition
 * @returns Array of auto-updated field names
 */
function getAutoUpdatedFields(schema) {
    var _a;
    var shape = schema.fields.shape;
    var autoUpdatedFields = [];
    for (var _i = 0, _b = Object.entries(shape); _i < _b.length; _i++) {
        var _c = _b[_i], fieldName = _c[0], fieldSchema = _c[1];
        if ((_a = fieldSchema._metadata) === null || _a === void 0 ? void 0 : _a.autoUpdate) {
            autoUpdatedFields.push(fieldName);
        }
    }
    return autoUpdatedFields;
}
/**
 * Extract field metadata from a schema.
 *
 * @param schema - Schema definition
 * @returns Map of field names to metadata
 */
function extractFieldMetadata(schema) {
    var shape = schema.fields.shape;
    var metadata = new Map();
    for (var _i = 0, _a = Object.entries(shape); _i < _a.length; _i++) {
        var _b = _a[_i], fieldName = _b[0], fieldSchema = _b[1];
        var fieldMetadata = fieldSchema._metadata;
        if (fieldMetadata) {
            metadata.set(fieldName, fieldMetadata);
        }
    }
    return metadata;
}
/**
 * Check if a schema has a specific relationship.
 *
 * @param schema - Schema definition
 * @param relationshipName - Relationship name
 * @returns True if relationship exists
 */
function hasRelationship(schema, relationshipName) {
    var _a;
    return !!((_a = schema.relationships) === null || _a === void 0 ? void 0 : _a[relationshipName]);
}
/**
 * Get relationship by name.
 *
 * @param schema - Schema definition
 * @param relationshipName - Relationship name
 * @returns Relationship definition or undefined
 */
function getRelationship(schema, relationshipName) {
    var _a;
    return (_a = schema.relationships) === null || _a === void 0 ? void 0 : _a[relationshipName];
}
/**
 * Get all relationships of a specific type.
 *
 * @param schema - Schema definition
 * @param type - Relationship type
 * @returns Array of relationship names
 */
function getRelationshipsByType(schema, type) {
    if (!schema.relationships) {
        return [];
    }
    return Object.entries(schema.relationships)
        .filter(function (_a) {
        var _ = _a[0], rel = _a[1];
        return rel.type === type;
    })
        .map(function (_a) {
        var name = _a[0];
        return name;
    });
}
/**
 * Schema registry for managing multiple schemas.
 */
var SchemaRegistry = /** @class */ (function () {
    function SchemaRegistry() {
        this.schemas = new Map();
    }
    /**
     * Register a schema.
     */
    SchemaRegistry.prototype.register = function (schema) {
        if (this.schemas.has(schema.name)) {
            throw new Error("Schema '".concat(schema.name, "' is already registered"));
        }
        this.schemas.set(schema.name, schema);
    };
    /**
     * Get a schema by name.
     */
    SchemaRegistry.prototype.get = function (name) {
        return this.schemas.get(name);
    };
    /**
     * Check if a schema exists.
     */
    SchemaRegistry.prototype.has = function (name) {
        return this.schemas.has(name);
    };
    /**
     * Get all registered schemas.
     */
    SchemaRegistry.prototype.all = function () {
        return Array.from(this.schemas.values());
    };
    /**
     * Get all schema names.
     */
    SchemaRegistry.prototype.names = function () {
        return Array.from(this.schemas.keys());
    };
    /**
     * Clear all schemas.
     */
    SchemaRegistry.prototype.clear = function () {
        this.schemas.clear();
    };
    /**
     * Validate all relationships across schemas.
     */
    SchemaRegistry.prototype.validateRelationships = function () {
        var errors = [];
        var schemaNames = new Set(this.names());
        for (var _i = 0, _a = this.all(); _i < _a.length; _i++) {
            var schema = _a[_i];
            if (!schema.relationships)
                continue;
            for (var _b = 0, _c = Object.entries(schema.relationships); _b < _c.length; _b++) {
                var _d = _c[_b], relName = _d[0], rel = _d[1];
                // Check if target schema exists
                if ('target' in rel && rel.target && !schemaNames.has(rel.target)) {
                    errors.push("Schema '".concat(schema.name, "' has relationship '").concat(relName, "' targeting unknown schema '").concat(rel.target, "'"));
                }
                // Check polymorphic targets
                if ('targets' in rel && rel.targets) {
                    for (var _e = 0, _f = rel.targets; _e < _f.length; _e++) {
                        var target = _f[_e];
                        if (!schemaNames.has(target)) {
                            errors.push("Schema '".concat(schema.name, "' has polymorphic relationship '").concat(relName, "' targeting unknown schema '").concat(target, "'"));
                        }
                    }
                }
                // Check through table for many-to-many
                if ('through' in rel && rel.through && !schemaNames.has(rel.through)) {
                    errors.push("Schema '".concat(schema.name, "' has many-to-many relationship '").concat(relName, "' with unknown through table '").concat(rel.through, "'"));
                }
            }
        }
        return {
            valid: errors.length === 0,
            errors: errors,
        };
    };
    return SchemaRegistry;
}());
exports.SchemaRegistry = SchemaRegistry;
/**
 * Global schema registry instance.
 */
exports.globalSchemaRegistry = new SchemaRegistry();
