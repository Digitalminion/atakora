/**
 * Atakora Data Schema DSL
 *
 * @remarks
 * Type-safe data model definition system using Zod for runtime validation
 * and TypeScript for compile-time type inference.
 *
 * ## Overview
 *
 * The Atakora Data Schema DSL provides a declarative way to define data models with:
 * - **Fields**: Zod-based field definitions with metadata
 * - **Relationships**: hasOne, hasMany, belongsTo, manyToMany, polymorphic
 * - **Authorization**: Declarative rules for CRUD operations
 * - **Indexes**: Database index definitions
 * - **Hooks**: Lifecycle hooks for custom logic
 * - **Computed Fields**: Derived fields calculated on demand
 * - **Validation**: Custom validation beyond type checking
 *
 * ## Example Usage
 *
 * ```typescript
 * import { defineSchema, Fields, allow, hasMany, belongsTo, z } from '@atakora/lib/schema/atakora';
 *
 * const UserSchema = defineSchema('User', {
 *   fields: z.object({
 *     id: Fields.id(),
 *     email: Fields.email().unique(),
 *     name: z.string().min(1).max(100),
 *     role: z.enum(['admin', 'user']).default('user'),
 *     createdAt: Fields.createdAt(),
 *     updatedAt: Fields.updatedAt()
 *   }),
 *
 *   authorization: {
 *     create: allow.authenticated(),
 *     read: allow.public(),
 *     update: allow.owner('id'),
 *     delete: allow.role('admin')
 *   },
 *
 *   relationships: {
 *     posts: hasMany('Post', 'authorId')
 *   },
 *
 *   indexes: {
 *     byEmail: { fields: ['email'], unique: true }
 *   }
 * });
 *
 * // Type inference
 * type User = InferSchemaType<typeof UserSchema>;
 * ```
 *
 * @packageDocumentation
 */
export type { SchemaDefinition, SchemaMetadata, AuthorizationRules, AuthorizationRule, AuthorizationRuleFunction, AuthorizationRuleConfig, AuthorizationContext, IndexDefinitions, IndexDefinition, RelationshipDefinitions, RelationshipDefinition, HasOneRelationship, HasManyRelationship, BelongsToRelationship, ManyToManyRelationship, PolymorphicRelationship, CascadeOptions, LifecycleHooks, LifecycleHook, LifecycleHookContext, ComputedFields, ComputedFieldDefinition, ComputedFieldContext, CustomValidation, ValidationRule, ValidationContext, ValidationResult, InferSchemaType, } from './schema-types';
export { field, Fields, FieldBuilder, getFieldMetadata, hasFieldMetadata, } from './field-types';
export type { FieldMetadata, ExtendedZodSchema, } from './field-types';
export { hasOne, hasMany, belongsTo, manyToMany, polymorphic, cascade, CascadeBuilder, RelationshipTypeGuards, getInverseRelationType, validateRelationship, } from './relationships';
export { AuthRuleBuilder, allow, evaluateAuthorizationRule, toFunctionAuthConfig, validateAuthorizationRules, } from './authorization';
export { defineSchema, validateSchema, getPrimaryKeyField, getUniqueFields, getIndexedFields, getAutoGeneratedFields, getAutoUpdatedFields, extractFieldMetadata, hasRelationship, getRelationship, getRelationshipsByType, SchemaRegistry, globalSchemaRegistry, } from './define-schema';
export { z } from 'zod';
//# sourceMappingURL=index.d.ts.map